diff --git a/.clinerules b/.clinerules
index b587214..3f79f96 100644
--- a/.clinerules
+++ b/.clinerules
@@ -20,10 +20,21 @@ Role: Defines functions for accessing and manipulating the SQLite database (conn
 [file: utils.py]
 Role: Collects general utility functions and helper functions.
 
+[file: config.py]
+Role: Holds configuration-related information for the bot.
+
+[file: formatters.py]
+Role: Contains utility functions for formatting and displaying data.
+
+[file: voice_state_manager.py]
+Role: Manages the state and logic related to voice channels.
+
+[file: backup_db.py]
+Role: Handles the database backup process.
+
 # You can also add more specific rules or information, e.g.,
 # [rule: Avoid direct database access outside of database.py]
 # Database operations should be performed through functions within database.py.
 
 # [rule: Command logic should reside in commands.py]
 # Slash command processing logic should be written in commands.py, and only called from main.py.
-
diff --git a/.gitignore b/.gitignore
index bcd54a7..bd34ce2 100644
--- a/.gitignore
+++ b/.gitignore
@@ -11,4 +11,5 @@ backups/
 __pycache__/
 memory-bank/
 review_results/
-task/
\ No newline at end of file
+task/
+old_version/
diff --git a/backup_db.py b/backup_db.py
index c9c68f9..6c46f62 100644
--- a/backup_db.py
+++ b/backup_db.py
@@ -2,48 +2,81 @@ import sqlite3
 import shutil
 import os
 import datetime
+import logging # logging モジュールをインポート
+from . import constants # constants モジュールをインポート
 
-DB_FILE = "voice_stats.db"
-BACKUP_DIR = "backups"
+# ロガーを取得
+logger = logging.getLogger(__name__)
+
+DB_FILE = constants.DB_FILE_NAME
+BACKUP_DIR = constants.BACKUP_DIR_NAME
 
 def backup_database():
+    logger.info("データベースのバックアップを開始します。")
     if not os.path.exists(BACKUP_DIR):
         os.makedirs(BACKUP_DIR)
+        logger.debug(f"バックアップディレクトリ '{BACKUP_DIR}' を作成しました。")
 
-    backup_file = os.path.join(BACKUP_DIR, f"voice_stats_{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}.db")
+    backup_file = os.path.join(BACKUP_DIR, f"{constants.BACKUP_FILE_PREFIX}{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}{constants.DB_FILE_EXTENSION}")
+    logger.debug(f"バックアップファイル名: {backup_file}")
 
+    con = None
+    bck = None
     try:
         # データベースに接続
         con = sqlite3.connect(DB_FILE)
+        logger.debug(f"データベース '{DB_FILE}' に接続しました。")
         # バックアップデータベースに接続 (存在しない場合は作成される)
         bck = sqlite3.connect(backup_file)
+        logger.debug(f"バックアップデータベース '{backup_file}' に接続しました。")
 
         # バックアップを実行
         # pages=0 は全てのページをバックアップすることを意味します
-        con.backup(bck, pages=0)
+        con.backup(bck, pages=constants.SQLITE_BACKUP_ALL_PAGES)
+        logger.debug("データベースのバックアップを実行しました。")
 
         bck.close()
         con.close()
-        print(f"データベースのバックアップが完了しました: {backup_file}")
+        logger.info(f"データベースのバックアップが完了しました: {backup_file}")
 
         # 古いバックアップファイルを削除
-        backup_files = [os.path.join(BACKUP_DIR, f) for f in os.listdir(BACKUP_DIR) if f.startswith("voice_stats_") and f.endswith(".db")]
+        logger.info("古いバックアップファイルの削除を開始します。")
+        backup_files = [os.path.join(BACKUP_DIR, f) for f in os.listdir(BACKUP_DIR) if f.startswith(constants.BACKUP_FILE_PREFIX) and f.endswith(constants.DB_FILE_EXTENSION)]
         backup_files.sort(key=lambda x: os.path.getmtime(x)) # 最終更新時間でソート
+        logger.debug(f"見つかったバックアップファイル数: {len(backup_files)}")
 
-        # 最新の7個以外のファイルを削除
-        if len(backup_files) > 7:
-            old_files = backup_files[:-7]
+        # 最新のconstants.NUM_BACKUP_FILES_TO_KEEP個以外のファイルを削除
+        if len(backup_files) > constants.NUM_BACKUP_FILES_TO_KEEP:
+            old_files = backup_files[:-constants.NUM_BACKUP_FILES_TO_KEEP]
+            logger.info(f"保持数 ({constants.NUM_BACKUP_FILES_TO_KEEP}) を超える古いファイルが {len(old_files)} 個見つかりました。")
             for old_file in old_files:
                 try:
                     os.remove(old_file)
-                    print(f"古いバックアップファイルを削除しました: {old_file}")
+                    logger.info(f"古いバックアップファイルを削除しました: {old_file}")
                 except OSError as e:
-                    print(f"古いバックアップファイルの削除中にエラーが発生しました: {e}")
+                    logger.error(f"古いバックアップファイルの削除中にエラーが発生しました: {e}")
+        else:
+            logger.debug("保持数を超える古いファイルはありませんでした。")
 
     except sqlite3.Error as e:
-        print(f"データベースのバックアップ中にエラーが発生しました: {e}")
+        logger.error(f"データベースのバックアップ中にSQLiteエラーが発生しました: {e}")
     except Exception as e:
-        print(f"予期しないエラーが発生しました: {e}")
+        logger.error(f"データベースのバックアップ中に予期しないエラーが発生しました: {e}")
+    finally:
+        if bck:
+            try:
+                bck.close()
+                logger.debug("バックアップデータベース接続を閉じました。")
+            except Exception as e:
+                logger.error(f"バックアップデータベース接続のクローズ中にエラーが発生しました: {e}")
+        if con:
+            try:
+                con.close()
+                logger.debug("元データベース接続を閉じました。")
+            except Exception as e:
+                logger.error(f"元データベース接続のクローズ中にエラーが発生しました: {e}")
+    logger.info("データベースのバックアップ処理が終了しました。")
+
 
 if __name__ == "__main__":
     backup_database()
diff --git a/commands.py b/commands.py
index 74120c0..c4c8a21 100644
--- a/commands.py
+++ b/commands.py
@@ -3,385 +3,511 @@ from discord import app_commands
 from discord.ext import commands # Cog を使用するためにインポート
 import datetime
 from zoneinfo import ZoneInfo
+import logging # logging モジュールをインポート
 
 from database import get_db_connection, get_total_call_time, get_guild_settings, update_guild_settings
 import config
 import voice_state_manager
 import formatters
 from voice_events import SleepCheckManager # SleepCheckManager をインポート
+import constants # constants モジュールをインポート
 
-# --- 月間統計作成用ヘルパー関数 ---
-async def get_monthly_statistics(guild, month: str):
-    conn = await get_db_connection()
-    cursor = await conn.cursor()
-
-    # 月間セッションの取得
-    await cursor.execute("""
-        SELECT start_time, duration, id FROM sessions
-        WHERE month_key = ?
-    """, (month,))
-    sessions_data = await cursor.fetchall()
-
-    sessions = []
-    session_ids = [session_row['id'] for session_row in sessions_data]
-
-    if session_ids:
-        # 全セッションの参加者を一度に取得
-        placeholders = ','.join('?' for _ in session_ids)
-        await cursor.execute(f"""
-            SELECT session_id, member_id FROM session_participants
-            WHERE session_id IN ({placeholders})
-        """, session_ids)
-        all_participants_data = await cursor.fetchall()
-
-        # セッションIDごとに参加者をグループ化
-        session_participants_map = {}
-        for participant_row in all_participants_data:
-            session_id = participant_row['session_id']
-            member_id = participant_row['member_id']
-            if session_id not in session_participants_map:
-                session_participants_map[session_id] = []
-            session_participants_map[session_id].append(member_id)
-
-        for session_row in sessions_data:
-            sessions.append({
-                "start_time": session_row['start_time'],
-                "duration": session_row['duration'],
-                "participants": session_participants_map.get(session_row['id'], [])
-            })
-
-    # メンバー別月間累計時間の取得
-    await cursor.execute("""
-        SELECT member_id, total_duration FROM member_monthly_stats
-        WHERE month_key = ?
-    """, (month,))
-    member_stats_data = await cursor.fetchall()
-    member_stats = {m['member_id']: m['total_duration'] for m in member_stats_data}
-
-    await conn.close()
-
-    # 平均通話時間の計算
-    if sessions:
-        monthly_avg = sum(sess["duration"] for sess in sessions) / len(sessions)
-    else:
-        monthly_avg = 0
-
-    # 最長通話の情報
-    if sessions:
-        longest_session = max(sessions, key=lambda s: s["duration"])
+# ロガーを取得
+logger = logging.getLogger(__name__)
+
+# --- コマンドを格納する Cog クラス ---
+class BotCommands(commands.Cog):
+    def __init__(self, bot, sleep_check_manager, voice_state_manager):
+        self.bot = bot
+        self.sleep_check_manager = sleep_check_manager
+        self.voice_state_manager = voice_state_manager
+        logger.info("BotCommands Cog initialized.")
+
+    # --- 月間統計作成用ヘルパー関数 ---
+    # 指定された月の通話統計情報をデータベースから取得し、整形して返します。
+    # データベース操作、データ集計、最長通話やランキングの算出を含みます。
+    async def _get_monthly_statistics(self, guild, month: str):
+        logger.info(f"Fetching monthly statistics for guild {guild.id}, month {month}")
+        # データベース接続を取得
+        conn = await get_db_connection()
+        cursor = await conn.cursor()
+
+        # 指定された月の全セッションを取得
+        await cursor.execute("""
+            SELECT start_time, duration, id FROM sessions
+            WHERE month_key = ?
+        """, (month,))
+        sessions_data = await cursor.fetchall()
+        logger.debug(f"Found {len(sessions_data)} sessions for month {month}")
+
+        sessions = []
+        session_ids = [session_row['id'] for session_row in sessions_data]
+
+        # 取得したセッションに参加したメンバーをまとめて取得し、セッションIDごとにグループ化
+        if session_ids:
+            placeholders = ','.join('?' for _ in session_ids)
+            await cursor.execute(f"""
+                SELECT session_id, member_id FROM session_participants
+                WHERE session_id IN ({placeholders})
+            """, session_ids)
+            all_participants_data = await cursor.fetchall()
+
+            session_participants_map = {}
+            for participant_row in all_participants_data:
+                session_id = participant_row['session_id']
+                member_id = participant_row['member_id']
+                if session_id not in session_participants_map:
+                    session_participants_map[session_id] = []
+                session_participants_map[session_id].append(member_id)
+
+            # セッションデータにメンバー情報を結合
+            for session_row in sessions_data:
+                sessions.append({
+                    "start_time": session_row['start_time'],
+                    "duration": session_row['duration'],
+                    "participants": session_participants_map.get(session_row['id'], [])
+                })
+
+        # 指定された月のメンバー別累計通話時間を取得
+        await cursor.execute("""
+            SELECT member_id, total_duration FROM member_monthly_stats
+            WHERE month_key = ?
+        """, (month,))
+        member_stats_data = await cursor.fetchall()
+        # メンバーIDをキーとした辞書に変換
+        member_stats = {m['member_id']: m['total_duration'] for m in member_stats_data}
+        logger.debug(f"Found stats for {len(member_stats)} members for month {month}")
+
+        # データベース接続を閉じる
+        await conn.close()
+        logger.debug("Database connection closed.")
+
+        # 月間平均通話時間の計算
+        if sessions:
+            monthly_avg = sum(sess["duration"] for sess in sessions) / len(sessions)
+            logger.debug(f"Calculated monthly average: {monthly_avg}")
+        else:
+            monthly_avg = 0
+            logger.debug("No sessions found, monthly average is 0.")
+
+        # 最長通話の情報取得と整形
+        if sessions:
+            longest_session = max(sessions, key=lambda s: s["duration"])
+            longest_duration = longest_session["duration"]
+            # UTCのISO形式からJSTに変換して日付をフォーマット
+            longest_date = formatters.convert_utc_to_jst(datetime.datetime.fromisoformat(longest_session["start_time"])).strftime('%Y/%m/%d')
+            longest_participants = longest_session.get("participants", [])
+            longest_participants_names = []
+            # 参加者IDからメンバー名を取得
+            for mid in longest_participants:
+                m_obj = guild.get_member(mid)
+                if m_obj:
+                    longest_participants_names.append(m_obj.display_name)
+                else:
+                    longest_participants_names.append(str(mid)) # メンバーが見つからない場合はIDを表示
+            longest_info = f"{formatters.format_duration(longest_duration)}（{longest_date}）\n参加: {', '.join(longest_participants_names)}"
+            logger.debug(f"Longest session: {longest_info}")
+        else:
+            longest_info = "なし"
+            logger.debug("No sessions found, no longest session.")
+
+        # メンバー別通話時間ランキングの作成
+        sorted_members = sorted(member_stats.items(), key=lambda x: x[1], reverse=True)
+        ranking_lines = []
+        for i, (member_id, duration) in enumerate(sorted_members, start=1):
+            m_obj = guild.get_member(member_id)
+            name = m_obj.display_name if m_obj else str(member_id)
+            ranking_lines.append(f"{i}.  {formatters.format_duration(duration)}  {name}")
+        ranking_text = "\n".join(ranking_lines) if ranking_lines else "なし"
+        logger.debug(f"Ranking text generated:\n{ranking_text}")
+
+        # 平均通話時間、最長通話情報、ランキングテキストを返す
+        return monthly_avg, longest_info, ranking_text
+
+    # --- 月間統計Embed作成用ヘルパー関数 ---
+    # _get_monthly_statistics から取得した情報をもとに、月間統計表示用のEmbedを作成します。
+    async def _create_monthly_stats_embed(self, guild, month: str):
+        logger.info(f"Creating monthly stats embed for guild {guild.id}, month {month}")
+        try:
+            year, mon = month.split("-")
+            month_display = f"{year}年{mon}月"
+        except Exception:
+            month_display = month # フォーマットが不正な場合はそのまま表示
+            logger.warning(f"Invalid month format: {month}")
+
+        # 月間統計情報を取得
+        monthly_avg, longest_info, ranking_text = await self._get_monthly_statistics(guild, month)
+
+        # 統計情報が取得できたかチェックし、データがない場合はNoneを返す
+        if monthly_avg == 0 and longest_info == "なし" and ranking_text == "なし":
+            logger.info(f"No statistics recorded for {month_display}")
+            return None, month_display
+
+        # Embedを作成し、フィールドを追加
+        embed = discord.Embed(title=f"【{month_display}】通話統計情報", color=constants.EMBED_COLOR_SUCCESS)
+        embed.add_field(name=constants.EMBED_FIELD_AVERAGE_CALL_TIME, value=f"{formatters.format_duration(monthly_avg)}", inline=False)
+        embed.add_field(name=constants.EMBED_FIELD_LONGEST_CALL, value=longest_info, inline=False)
+        embed.add_field(name=constants.EMBED_FIELD_CALL_RANKING, value=ranking_text, inline=False)
+        logger.debug("Monthly stats embed created successfully.")
+
+        # 作成したEmbedと表示用の月を返す
+        return embed, month_display
+
+    # --- 年間統計作成用ヘルパー関数 ---
+    # 指定された年度の通話統計情報をデータベースから取得し、整形してEmbedを作成します。
+    # データベース操作、データ集計、最長通話やランキングの算出を含みます。
+    async def _create_annual_stats_embed(self, guild, year: str):
+        logger.info(f"Creating annual stats embed for guild {guild.id}, year {year}")
+        # データベース接続を取得
+        conn = await get_db_connection()
+        cursor = await conn.cursor()
+
+        # 対象年度の全セッションを取得
+        await cursor.execute("""
+            SELECT start_time, duration, id FROM sessions
+            WHERE strftime('%Y', start_time) = ?
+        """, (year,))
+        sessions_data = await cursor.fetchall()
+        logger.debug(f"Found {len(sessions_data)} sessions for year {year}")
+
+        sessions_all = []
+        session_ids = [session_row['id'] for session_row in sessions_data]
+
+        if session_ids:
+            # 全セッションの参加者を一度に取得
+            placeholders = ','.join('?' for _ in session_ids)
+            await cursor.execute(f"""
+                SELECT session_id, member_id FROM session_participants
+                WHERE session_id IN ({placeholders})
+            """, session_ids)
+            all_participants_data = await cursor.fetchall()
+
+            # セッションIDごとに参加者をグループ化
+            session_participants_map = {}
+            for participant_row in all_participants_data:
+                session_id = participant_row['session_id']
+                member_id = participant_row['member_id']
+                if session_id not in session_participants_map:
+                    session_participants_map[session_id] = []
+                session_participants_map[session_id].append(member_id)
+
+            # セッションデータにメンバー情報を結合
+            for session_row in sessions_data:
+                sessions_all.append({
+                    "start_time": session_row['start_time'],
+                    "duration": session_row['duration'],
+                    "participants": session_participants_map.get(session_row['id'], [])
+                })
+
+        # 対象年度のメンバー別累計時間を全て取得
+        await cursor.execute("""
+            SELECT member_id, SUM(total_duration) as total_duration
+            FROM member_monthly_stats
+            WHERE strftime('%Y', month_key) = ?
+            GROUP BY member_id
+        """, (year,))
+        members_total_data = await cursor.fetchall()
+        # メンバーIDをキーとした辞書に変換
+        members_total = {m['member_id']: m['total_duration'] for m in members_total_data}
+        logger.debug(f"Found stats for {len(members_total)} members for year {year}")
+
+        # データベース接続を閉じる
+        await conn.close()
+        logger.debug("Database connection closed.")
+
+        year_display = f"{year}年"
+        # セッションデータがない場合はNoneを返す
+        if not sessions_all:
+            logger.info(f"No sessions found for year {year}")
+            return None, year_display
+
+        # 年間合計通話時間、セッション数、平均通話時間の計算
+        total_duration = sum(sess["duration"] for sess in sessions_all)
+        total_sessions = len(sessions_all)
+        avg_duration = total_duration / total_sessions if total_sessions else 0
+        logger.debug(f"Calculated annual total duration: {total_duration}, total sessions: {total_sessions}, average duration: {avg_duration}")
+
+        # 最長セッションの情報取得と整形
+        longest_session = max(sessions_all, key=lambda s: s["duration"])
         longest_duration = longest_session["duration"]
-        # UTCのISO形式からJSTに変換
+        # UTCのISO形式からJSTに変換して日付をフォーマット
         longest_date = formatters.convert_utc_to_jst(datetime.datetime.fromisoformat(longest_session["start_time"])).strftime('%Y/%m/%d')
-        longest_participants = longest_session.get("participants", [])
+        longest_participants = longest_session["participants"]
         longest_participants_names = []
+        # 参加者IDからメンバー名を取得
         for mid in longest_participants:
             m_obj = guild.get_member(mid)
             if m_obj:
                 longest_participants_names.append(m_obj.display_name)
             else:
-                longest_participants_names.append(str(mid))
+                longest_participants_names.append(str(mid)) # メンバーが見つからない場合はIDを表示
         longest_info = f"{formatters.format_duration(longest_duration)}（{longest_date}）\n参加: {', '.join(longest_participants_names)}"
-    else:
-        longest_info = "なし"
-
-    # メンバー別通話時間ランキング
-    sorted_members = sorted(member_stats.items(), key=lambda x: x[1], reverse=True)
-    ranking_lines = []
-    for i, (member_id, duration) in enumerate(sorted_members, start=1):
-        m_obj = guild.get_member(member_id)
-        name = m_obj.display_name if m_obj else str(member_id)
-        ranking_lines.append(f"{i}.  {formatters.format_duration(duration)}  {name}")
-    ranking_text = "\n".join(ranking_lines) if ranking_lines else "なし"
-
-    return monthly_avg, longest_info, ranking_text
-
-# --- 月間統計Embed作成用ヘルパー関数 ---
-async def create_monthly_stats_embed(guild, month: str):
-    try:
-        year, mon = month.split("-")
-        month_display = f"{year}年{mon}月"
-    except Exception:
-        month_display = month
-
-    monthly_avg, longest_info, ranking_text = await get_monthly_statistics(guild, month)
-
-    # 統計情報が取得できたかチェック
-    if monthly_avg == 0 and longest_info == "なし" and ranking_text == "なし":
-         return None, month_display
-
-    embed = discord.Embed(title=f"【{month_display}】通話統計情報", color=0x00ff00)
-    embed.add_field(name="平均通話時間", value=f"{formatters.format_duration(monthly_avg)}", inline=False)
-    embed.add_field(name="最長通話", value=longest_info, inline=False)
-    embed.add_field(name="通話時間ランキング", value=ranking_text, inline=False)
-
-    return embed, month_display
-
-# --- 年間統計作成用ヘルパー関数 ---
-async def create_annual_stats_embed(guild, year: str):
-    conn = await get_db_connection()
-    cursor = await conn.cursor()
-
-    # 対象年度のセッションを全て取得
-    await cursor.execute("""
-        SELECT start_time, duration, id FROM sessions
-        WHERE strftime('%Y', start_time) = ?
-    """, (year,))
-    sessions_data = await cursor.fetchall()
-
-    sessions_all = []
-    session_ids = [session_row['id'] for session_row in sessions_data]
-
-    if session_ids:
-        # 全セッションの参加者を一度に取得
-        placeholders = ','.join('?' for _ in session_ids)
-        await cursor.execute(f"""
-            SELECT session_id, member_id FROM session_participants
-            WHERE session_id IN ({placeholders})
-        """, session_ids)
-        all_participants_data = await cursor.fetchall()
-
-        # セッションIDごとに参加者をグループ化
-        session_participants_map = {}
-        for participant_row in all_participants_data:
-            session_id = participant_row['session_id']
-            member_id = participant_row['member_id']
-            if session_id not in session_participants_map:
-                session_participants_map[session_id] = []
-            session_participants_map[session_id].append(member_id)
-
-        for session_row in sessions_data:
-            sessions_all.append({
-                "start_time": session_row['start_time'],
-                "duration": session_row['duration'],
-                "participants": session_participants_map.get(session_row['id'], [])
-            })
-
-    # 対象年度のメンバー別累計時間を全て取得
-    await cursor.execute("""
-        SELECT member_id, SUM(total_duration) as total_duration
-        FROM member_monthly_stats
-        WHERE strftime('%Y', month_key) = ?
-        GROUP BY member_id
-    """, (year,))
-    members_total_data = await cursor.fetchall()
-    members_total = {m['member_id']: m['total_duration'] for m in members_total_data}
-
-    await conn.close()
-
-    year_display = f"{year}年"
-    if not sessions_all:
-        return None, year_display
-
-    total_duration = sum(sess["duration"] for sess in sessions_all)
-    total_sessions = len(sessions_all)
-    avg_duration = total_duration / total_sessions if total_sessions else 0
-
-    # 最長セッション
-    longest_session = max(sessions_all, key=lambda s: s["duration"])
-    longest_duration = longest_session["duration"]
-    longest_date = formatters.convert_utc_to_jst(datetime.datetime.fromisoformat(longest_session["start_time"])).strftime('%Y/%m/%d')
-    longest_participants = longest_session["participants"]
-    longest_participants_names = []
-    for mid in longest_participants:
-        m_obj = guild.get_member(mid)
-        if m_obj:
-            longest_participants_names.append(m_obj.display_name)
-        else:
-            longest_participants_names.append(str(mid))
-    longest_info = f"{formatters.format_duration(longest_duration)}（{longest_date}）\n参加: {', '.join(longest_participants_names)}"
+        logger.debug(f"Longest annual session: {longest_info}")
 
-    # メンバー別ランキング（累計時間）
-    sorted_members = sorted(members_total.items(), key=lambda x: x[1], reverse=True)
-    ranking_lines = []
-    for i, (member_id, duration) in enumerate(sorted_members, start=1):
-        m_obj = guild.get_member(member_id)
-        name = m_obj.display_name if m_obj else str(member_id)
-        ranking_lines.append(f"{i}.  {formatters.format_duration(duration)}  {name}")
-    ranking_text = "\n".join(ranking_lines) if ranking_lines else "なし"
+        # メンバー別ランキング（累計時間）の作成
+        sorted_members = sorted(members_total.items(), key=lambda x: x[1], reverse=True)
+        ranking_lines = []
+        for i, (member_id, duration) in enumerate(sorted_members, start=1):
+            m_obj = guild.get_member(member_id)
+            name = m_obj.display_name if m_obj else str(member_id)
+            ranking_lines.append(f"{i}.  {formatters.format_duration(duration)}  {name}")
+        ranking_text = "\n".join(ranking_lines) if ranking_lines else "なし"
+        logger.debug(f"Annual ranking text generated:\n{ranking_text}")
 
-    embed = discord.Embed(title=f"【{year_display}】年間通話統計情報", color=0x00ff00)
-    embed.add_field(name="年間: 平均通話時間", value=f"{formatters.format_duration(avg_duration)}", inline=False)
-    embed.add_field(name="年間: 最長通話", value=longest_info, inline=False)
-    embed.add_field(name="年間: 通話時間ランキング", value=ranking_text, inline=False)
-    return embed, year_display
+        # Embedを作成し、フィールドを追加
+        embed = discord.Embed(title=f"【{year_display}】年間通話統計情報", color=constants.EMBED_COLOR_SUCCESS)
+        embed.add_field(name="年間: 平均通話時間", value=f"{formatters.format_duration(avg_duration)}", inline=False)
+        embed.add_field(name="年間: 最長通話", value=longest_info, inline=False)
+        embed.add_field(name="年間: 通話時間ランキング", value=ranking_text, inline=False)
+        logger.debug("Annual stats embed created successfully.")
+        # 作成したEmbedと表示用の年を返す
+        return embed, year_display
 
 
-# --- コマンドを格納する Cog クラス ---
-class BotCommands(commands.Cog):
-    def __init__(self, bot, sleep_check_manager, voice_state_manager):
-        self.bot = bot
-        self.sleep_check_manager = sleep_check_manager
-        self.voice_state_manager = voice_state_manager
 
     # --- /monthly_stats コマンド ---
+    # 月間通話統計を表示するコマンドのコールバック関数
     @app_commands.command(name="monthly_stats", description="月間通話統計を表示します") # nameとdescriptionを明示
     @app_commands.describe(month="表示する年月（形式: YYYY-MM）省略時は今月")
     @app_commands.guild_only()
     async def monthly_stats_callback(self, interaction: discord.Interaction, month: str = None):
+        logger.info(f"Received /monthly_stats command from {interaction.user.id} in guild {interaction.guild.id} with month: {month}")
+        # 月の指定がなければ現在の月を使用
         if month is None:
             now = datetime.datetime.now(datetime.timezone.utc)
             month = now.strftime("%Y-%m")
+            logger.debug(f"Month not specified, using current month: {month}")
 
+        # 指定された月の形式を検証
         try:
             year, mon = month.split("-")
             month_display = f"{year}年{mon}月"
         except ValueError:
+            logger.warning(f"Invalid month format received: {month}")
             await interaction.response.send_message("指定された月の形式が正しくありません。形式は YYYY-MM で指定してください。", ephemeral=True)
             return
 
-        embed, month_display = await create_monthly_stats_embed(interaction.guild, month)
+        # 月間統計Embedを作成
+        embed, month_display = await self._create_monthly_stats_embed(interaction.guild, month)
 
+        # Embedが作成できたか確認し、結果を送信
         if embed is None:
+            logger.info(f"No monthly stats found for {month_display}")
             await interaction.response.send_message(f"{month_display}は通話統計情報が記録されていません", ephemeral=True)
             return
 
         await interaction.response.send_message(embed=embed, ephemeral=True)
+        logger.info(f"/monthly_stats command executed successfully for {month_display}")
 
     # --- /total_time コマンド ---
+    # 指定したメンバーの総通話時間を表示するコマンドのコールバック関数
     @app_commands.command(name="total_time", description="指定したメンバーの総通話時間を表示します") # nameとdescriptionを明示
     @app_commands.describe(member="通話時間を確認するメンバー（省略時は自分）")
     @app_commands.guild_only()
     async def total_time_callback(self, interaction: discord.Interaction, member: discord.Member = None):
+        logger.info(f"Received /total_time command from {interaction.user.id} in guild {interaction.guild.id} for member: {member}")
+        # メンバーの指定がなければコマンド実行ユーザーを使用
         member = member or interaction.user
+        logger.debug(f"Checking total time for member: {member.id}")
+        # メンバーの総通話時間をデータベースから取得
         total_seconds = await get_total_call_time(member.id)
+        logger.debug(f"Total time for {member.id}: {total_seconds} seconds")
 
-        embed = discord.Embed(color=discord.Color.blue())
+        # 結果表示用のEmbedを作成
+        embed = discord.Embed(color=constants.EMBED_COLOR_INFO)
         embed.set_author(name=member.display_name, icon_url=member.display_avatar.url)
 
+        # 通話時間に応じて表示内容を分岐
         if total_seconds == 0:
-            embed.add_field(name="総通話時間", value="通話履歴はありません。", inline=False)
+            embed.add_field(name=constants.EMBED_FIELD_TOTAL_CALL_TIME, value=constants.MESSAGE_NO_CALL_HISTORY, inline=False)
+            logger.info(f"No call history found for member {member.id}")
         else:
             formatted_time = formatters.format_duration(total_seconds)
-            embed.add_field(name="総通話時間", value=formatted_time, inline=False)
+            embed.add_field(name=constants.EMBED_FIELD_TOTAL_CALL_TIME, value=formatted_time, inline=False)
+            logger.info(f"Total call time for member {member.id}: {formatted_time}")
 
+        # 結果を送信
         await interaction.response.send_message(embed=embed, ephemeral=True)
+        logger.info(f"/total_time command executed successfully for member {member.id}")
 
     # --- /total_call_ranking コマンド ---
+    # 総通話時間ランキングを表示するコマンドのコールバック関数
     @app_commands.command(name="call_ranking", description="総通話時間ランキングを表示します") # nameとdescriptionを明示
     @app_commands.guild_only()
     async def call_ranking_callback(self, interaction: discord.Interaction):
+        logger.info(f"Received /call_ranking command from {interaction.user.id} in guild {interaction.guild.id}")
         guild = interaction.guild
         members = guild.members
+        logger.debug(f"Fetching total call times for {len(members)} members in guild {guild.id}")
 
-        # メンバーの通話時間を取得
+        # サーバー内の全メンバーの通話時間を取得
         member_call_times = {}
         for member in members:
             total_seconds = await get_total_call_time(member.id)
-            if total_seconds > 0:  # 通話時間が0より大きいメンバーのみを追加
+            if total_seconds > 0:  # 通話時間が0より大きいメンバーのみを対象
                 member_call_times[member.id] = total_seconds
+        logger.debug(f"Found call times for {len(member_call_times)} members with > 0 call time.")
 
-        # 通話時間でランキングを作成
+        # 通話時間でメンバーを降順にソートしてランキングを作成
         sorted_members = sorted(member_call_times.items(), key=lambda x: x[1], reverse=True)
+        logger.debug(f"Sorted {len(sorted_members)} members for ranking.")
 
+        # ランキングデータがあるか確認し、結果を送信
         if not sorted_members:
-            await interaction.response.send_message("通話履歴がないため、ランキングを表示できません。", ephemeral=True)
+            logger.info("No ranking data found.")
+            await interaction.response.send_message(constants.MESSAGE_NO_RANKING_DATA, ephemeral=True)
         else:
-            embed = discord.Embed(title="総通話時間ランキング", color=discord.Color.gold())
+            # ランキング表示用のEmbedを作成
+            embed = discord.Embed(title=constants.EMBED_TITLE_TOTAL_CALL_RANKING, color=constants.EMBED_COLOR_MILESTONE)
             ranking_text = ""
-            for i, (member_id, total_seconds) in enumerate(sorted_members[:10], start=1):  # 上位10名を表示
+            # constants.RANKING_LIMIT で定義された上位メンバーのみを表示
+            for i, (member_id, total_seconds) in enumerate(sorted_members[:constants.RANKING_LIMIT], start=1):
                 member = guild.get_member(member_id)
                 if member:
                     formatted_time = formatters.format_duration(total_seconds)
                     ranking_text += f"{i}. {formatted_time} {member.display_name}\n"
+            # ランキング表示件数に制限があることを示すコメントを追加
+            if len(sorted_members) > constants.RANKING_LIMIT:
+                ranking_text += f"...\n(上位 {constants.RANKING_LIMIT} 名を表示)"
             embed.add_field(name="", value=ranking_text, inline=False)
             await interaction.response.send_message(embed=embed, ephemeral=True)
+            logger.info(f"/call_ranking command executed successfully, showing top {min(len(sorted_members), constants.RANKING_LIMIT)}.")
 
     # --- /call_duration コマンド ---
+    # 現在の通話状況を表示するコマンドのコールバック関数
     @app_commands.command(name="call_duration", description="現在の通話状況を表示します") # nameとdescriptionを明示
     @app_commands.guild_only()
     async def call_duration_callback(self, interaction: discord.Interaction):
+        logger.info(f"Received /call_duration command from {interaction.user.id} in guild {interaction.guild.id}")
         guild_id = interaction.guild.id
-        now = datetime.datetime.now(datetime.timezone.utc)
-        active_calls_found = False
-
-        embed = discord.Embed(color=discord.Color.blue())
-        embed.set_author(name="現在の通話状況")
-
-        # voice_state_manager から get_active_call_durations を使用
+        # voice_state_manager から現在アクティブな通話とその継続時間を取得
         active_calls = self.voice_state_manager.get_active_call_durations(guild_id)
+        logger.debug(f"Found {len(active_calls)} active calls in guild {guild_id}")
+
+        # 結果表示用のEmbedを作成
+        embed = discord.Embed(color=constants.EMBED_COLOR_INFO)
+        embed.set_author(name=constants.EMBED_TITLE_CURRENT_CALL_STATUS)
 
+        # アクティブな通話があるか確認し、結果を送信
         if not active_calls:
-            await interaction.response.send_message("現在、このサーバーで2人以上が参加している通話はありません。", ephemeral=True)
+            logger.info("No active calls found.")
+            await interaction.response.send_message(constants.MESSAGE_NO_ACTIVE_CALLS, ephemeral=True)
         else:
+            # 各通話チャンネルと継続時間をEmbedのフィールドに追加
             for call in active_calls:
                 embed.add_field(name=f"{call['channel_name']}", value=call['duration'], inline=False)
             await interaction.response.send_message(embed=embed, ephemeral=True)
+            logger.info("/call_duration command executed successfully.")
 
     # --- /help コマンド ---
+    # コマンド一覧を表示するコマンドのコールバック関数
     @app_commands.command(name="help", description="コマンド一覧を表示します") # nameとdescriptionを明示
     @app_commands.guild_only()
     async def help_callback(self, interaction: discord.Interaction):
+        logger.info(f"Received /help command from {interaction.user.id} in guild {interaction.guild.id}")
         # interaction.client は bot インスタンスを参照します
+        # サーバーで利用可能なコマンドリストを取得
         commands = self.bot.tree.get_commands(guild=interaction.guild)
-        embed = discord.Embed(title="コマンド一覧", color=0x00ff00)
+        logger.debug(f"Found {len(commands)} commands for guild {interaction.guild.id}")
+        # コマンド一覧表示用のEmbedを作成
+        embed = discord.Embed(title=constants.EMBED_TITLE_COMMAND_LIST, color=constants.EMBED_COLOR_SUCCESS)
+        # 各コマンドの名前と説明をEmbedのフィールドに追加
         for command in commands:
             embed.add_field(name=command.name, value=command.description, inline=False)
+        # 結果を送信
         await interaction.response.send_message(embed=embed, ephemeral=True)
+        logger.info("/help command executed successfully.")
 
     # 管理者用：通知先チャンネル変更コマンド
-    @app_commands.command(name="changesendchannel", description="通知を送信するチャンネルを設定します") # nameとdescriptionを明示
-    @app_commands.default_permissions(administrator=True)
+    # 通知を送信するチャンネルを設定するコマンドのコールバック関数
+    @app_commands.command(name="changesendchannel", description="通知を送信するチャンネルを設定します（管理者用）") # nameとdescriptionを明示
+    @app_commands.default_permissions(administrator=True) # 管理者権限が必要
     @app_commands.describe(channel="通知を送信するチャンネル")
     @app_commands.guild_only()
     async def changesendchannel_callback(self, interaction: discord.Interaction, channel: discord.TextChannel):
+        logger.info(f"Received /changesendchannel command from {interaction.user.id} in guild {interaction.guild.id} with channel: {channel.id}")
         guild_id = interaction.guild.id
-        # config から get_notification_channel_id を使用
+        # config から現在の通知チャンネルIDを取得
         current_channel_id = config.get_notification_channel_id(guild_id)
+        logger.debug(f"Current notification channel ID for guild {guild_id}: {current_channel_id}")
 
+        # 現在のチャンネルと同じか確認し、結果を送信
         if current_channel_id is not None and current_channel_id == channel.id:
             # interaction.client は bot インスタンスを参照します
             current_channel = self.bot.get_channel(current_channel_id)
-            await interaction.response.send_message(f"すでに {current_channel.mention} で設定済みです。", ephemeral=True)
+            logger.info(f"Notification channel already set to {channel.id}")
+            await interaction.response.send_message(constants.MESSAGE_NOTIFICATION_CHANNEL_ALREADY_SET.format(current_channel=current_channel), ephemeral=True)
         else:
-            # config から set_notification_channel_id を使用
+            # config を使用して通知チャンネルIDを更新
             config.set_notification_channel_id(guild_id, channel.id)
-            await interaction.response.send_message(f"通知先のチャンネルが {channel.mention} に設定されました。", ephemeral=True)
+            logger.info(f"Notification channel set to {channel.id} for guild {guild_id}")
+            await interaction.response.send_message(constants.MESSAGE_NOTIFICATION_CHANNEL_SET.format(channel=channel), ephemeral=True)
+        logger.info("/changesendchannel command executed successfully.")
 
     # 管理者用：年間統計情報送信デバッグコマンド
+    # 指定した年度の年間通話統計情報を表示するコマンドのコールバック関数
     @app_commands.command(name="debug_annual_stats", description="指定した年度の年間通話統計情報を表示します（管理者用）") # nameとdescriptionを明示
-    @app_commands.default_permissions(administrator=True)
+    @app_commands.default_permissions(administrator=True) # 管理者権限が必要
     @app_commands.describe(year="表示する年度（形式: YYYY）。省略時は今年")
     @app_commands.guild_only()
     async def debug_annual_stats_callback(self, interaction: discord.Interaction, year: str = None):
+        logger.info(f"Received /debug_annual_stats command from {interaction.user.id} in guild {interaction.guild.id} with year: {year}")
         # 年度の指定がなければ現在の年度を使用
         if year is None:
-            now = datetime.datetime.now(ZoneInfo("Asia/Tokyo"))
+            now = datetime.datetime.now(ZoneInfo(constants.TIMEZONE_JST))
             year = str(now.year)
+        logger.debug(f"Year not specified, using current year: {year}")
 
-        embed, display = await create_annual_stats_embed(interaction.guild, year)
+        # 年間統計Embedを作成
+        embed, display = await self._create_annual_stats_embed(interaction.guild, year)
+        # Embedが作成できたか確認し、結果を送信
         if embed:
             await interaction.response.send_message(embed=embed, ephemeral=True)
+            logger.info(f"/debug_annual_stats command executed successfully for year {year}")
         else:
-            await interaction.response.send_message(f"{display}の通話統計情報が記録されていません", ephemeral=True)
+            logger.info(f"No annual stats found for year {year}")
+            await interaction.response.send_message(f"{display}{constants.MESSAGE_NO_CALL_RECORDS}", ephemeral=True)
+        logger.info("/debug_annual_stats command finished.")
 
     # 管理者用：寝落ち確認設定変更コマンド
+    # 寝落ち確認の設定を変更するコマンドのコールバック関数
     @app_commands.command(name="set_sleep_check", description="寝落ち確認の設定を変更します（管理者用）") # nameとdescriptionを明示
-    @app_commands.default_permissions(administrator=True)
+    @app_commands.default_permissions(administrator=True) # 管理者権限が必要
     @app_commands.describe(lonely_timeout_minutes="一人以下の状態が続く時間（分単位）", reaction_wait_minutes="反応を待つ時間（分単位）")
     @app_commands.guild_only()
     async def set_sleep_check_callback(self, interaction: discord.Interaction, lonely_timeout_minutes: int = None, reaction_wait_minutes: int = None):
+        logger.info(f"Received /set_sleep_check command from {interaction.user.id} in guild {interaction.guild.id} with lonely_timeout_minutes: {lonely_timeout_minutes}, reaction_wait_minutes: {reaction_wait_minutes}")
+        # パラメータの指定がない場合は現在の設定を表示
         if lonely_timeout_minutes is None and reaction_wait_minutes is None:
             settings = await get_guild_settings(interaction.guild.id)
+            logger.info(f"Displaying current sleep check settings for guild {interaction.guild.id}")
             await interaction.response.send_message(
-                f"現在の寝落ち確認設定:\n"
-                f"一人以下の状態が続く時間: {settings['lonely_timeout_minutes']} 分\n"
-                f"反応を待つ時間: {settings['reaction_wait_minutes']} 分",
+                constants.MESSAGE_CURRENT_SLEEP_CHECK_SETTINGS +
+                f"{constants.EMBED_FIELD_LONELY_TIMEOUT}: {settings[constants.COLUMN_LONELY_TIMEOUT_MINUTES]} 分\n" +
+                f"{constants.EMBED_FIELD_REACTION_WAIT}: {settings[constants.COLUMN_REACTION_WAIT_MINUTES]} 分",
                 ephemeral=True
             )
             return
 
+        # パラメータのバリデーション
         if lonely_timeout_minutes is not None and lonely_timeout_minutes <= 0:
-            await interaction.response.send_message("一人以下の状態が続く時間は1分以上に設定してください。", ephemeral=True)
+            logger.warning(f"Invalid lonely_timeout_minutes value: {lonely_timeout_minutes}")
+            await interaction.response.send_message(constants.MESSAGE_LONELY_TIMEOUT_MIN_ERROR, ephemeral=True)
             return
         if reaction_wait_minutes is not None and reaction_wait_minutes <= 0:
-            await interaction.response.send_message("反応を待つ時間は1分以上に設定してください。", ephemeral=True)
+            logger.warning(f"Invalid reaction_wait_minutes value: {reaction_wait_minutes}")
+            await interaction.response.send_message(constants.MESSAGE_REACTION_WAIT_MIN_ERROR, ephemeral=True)
             return
 
+        # ギルド設定を更新
         await update_guild_settings(interaction.guild.id, lonely_timeout_minutes=lonely_timeout_minutes, reaction_wait_minutes=reaction_wait_minutes)
+        logger.info(f"Sleep check settings updated for guild {interaction.guild.id}")
+        # 更新後の設定を取得して表示
         settings = await get_guild_settings(interaction.guild.id)
         await interaction.response.send_message(
-            f"寝落ち確認設定を更新しました:\n"
-            f"一人以下の状態が続く時間: {settings['lonely_timeout_minutes']} 分\n"
-            f"反応を待つ時間: {settings['reaction_wait_minutes']} 分",
+            constants.MESSAGE_SLEEP_CHECK_SETTINGS_UPDATED +
+            f"{constants.EMBED_FIELD_LONELY_TIMEOUT}: {settings[constants.COLUMN_LONELY_TIMEOUT_MINUTES]} 分\n" +
+            f"{constants.EMBED_FIELD_REACTION_WAIT}: {settings[constants.COLUMN_REACTION_WAIT_MINUTES]} 分",
             ephemeral=True
         )
+        logger.info("/set_sleep_check command executed successfully.")
diff --git a/config.py b/config.py
index 332b696..d366815 100644
--- a/config.py
+++ b/config.py
@@ -1,44 +1,70 @@
 import os
 import json
+import logging # logging モジュールをインポート
+import constants # constants モジュールをインポート
+
+# ロガーを取得
+logger = logging.getLogger(__name__)
 
 # サーバーごとの通知先チャンネルIDを保存する辞書
 # キー: guild_id (str), 値: channel_id (int)
 _server_notification_channels = {}
 
 # 通知チャンネル設定を保存するファイルのパス
-CHANNELS_FILE = "channels.json"
+CHANNELS_FILE = constants.CHANNELS_FILE_NAME
 
 def save_channels_to_file():
     """通知チャンネル設定をファイルに保存する"""
-    with open(CHANNELS_FILE, "w") as f:
-        json.dump(_server_notification_channels, f)
+    logger.info(f"通知チャンネル設定をファイル '{CHANNELS_FILE}' に保存します。")
+    try:
+        with open(CHANNELS_FILE, "w") as f:
+            json.dump(_server_notification_channels, f)
+        logger.debug("通知チャンネル設定の保存が完了しました。")
+    except Exception as e:
+        logger.error(f"通知チャンネル設定のファイル '{CHANNELS_FILE}' への保存中にエラーが発生しました: {e}")
+
 
 def load_channels_from_file():
     """ファイルから通知チャンネル設定を読み込む"""
+    logger.info(f"通知チャンネル設定をファイル '{CHANNELS_FILE}' から読み込みます。")
     global _server_notification_channels
     if os.path.exists(CHANNELS_FILE):
-        with open(CHANNELS_FILE, "r") as f:
-            try:
+        try:
+            with open(CHANNELS_FILE, "r") as f:
                 content = f.read().strip()
                 if content:
                     _server_notification_channels = json.loads(content)
+                    logger.debug(f"ファイル '{CHANNELS_FILE}' から通知チャンネル設定を読み込みました。")
                 else:
                     _server_notification_channels = {}
-            except json.JSONDecodeError:
-                print(f"エラー: {CHANNELS_FILE} の読み込みに失敗しました。")
-                _server_notification_channels = {}
+                    logger.debug(f"ファイル '{CHANNELS_FILE}' は空でした。空の設定をロードします。")
+        except json.JSONDecodeError:
+            logger.error(f"エラー: {CHANNELS_FILE} の読み込みに失敗しました。JSON形式が不正です。")
+            _server_notification_channels = {}
+        except Exception as e:
+            logger.error(f"通知チャンネル設定のファイル '{CHANNELS_FILE}' からの読み込み中にエラーが発生しました: {e}")
+            _server_notification_channels = {}
     else:
         _server_notification_channels = {}
-    # キーを文字列に統一
+        logger.info(f"通知チャンネル設定ファイル '{CHANNELS_FILE}' が見つかりませんでした。空の設定をロードします。")
+
+    # JSONに保存されるキーは文字列になるため、読み込み後も辞書のキーを文字列に統一する
     _server_notification_channels = {str(guild_id): channel_id for guild_id, channel_id in _server_notification_channels.items()}
+    logger.debug(f"ロードされた通知チャンネル設定: {_server_notification_channels}")
+
 
 def get_notification_channel_id(guild_id: int):
     """指定されたギルドの通知チャンネルIDを取得する"""
-    return _server_notification_channels.get(str(guild_id))
+    guild_id_str = str(guild_id)
+    channel_id = _server_notification_channels.get(guild_id_str)
+    logger.debug(f"ギルド {guild_id} の通知チャンネルIDを取得しました: {channel_id}")
+    return channel_id
 
 def set_notification_channel_id(guild_id: int, channel_id: int):
     """指定されたギルドの通知チャンネルIDを設定する"""
-    _server_notification_channels[str(guild_id)] = channel_id
+    guild_id_str = str(guild_id)
+    _server_notification_channels[guild_id_str] = channel_id
+    logger.info(f"ギルド {guild_id} の通知チャンネルIDを {channel_id} に設定しました。")
     save_channels_to_file()
 
 # 初期ロード
diff --git a/database.py b/database.py
index 95e7c17..038fa00 100644
--- a/database.py
+++ b/database.py
@@ -1,160 +1,345 @@
 import aiosqlite
 import os
+import logging # logging モジュールをインポート
+import constants # constants モジュールをインポート
+
+# ロガーを取得
+logger = logging.getLogger(__name__)
 
 # データベースファイル名
-DB_FILE = "voice_stats.db"
+DB_FILE = constants.DB_FILE_NAME
 
 async def init_db():
+    logger.info(f"データベース '{DB_FILE}' の初期化を開始します。")
     # データベースファイルが存在しない場合にメッセージを出力
     if not os.path.exists(DB_FILE):
-        print(f"データベースファイル '{DB_FILE}' が見つかりませんでした。新規作成します。")
-
-    conn = await aiosqlite.connect(DB_FILE)
-    cursor = await conn.cursor()
-
-    # sessions テーブル
-    await cursor.execute("""
-        CREATE TABLE IF NOT EXISTS sessions (
-            id INTEGER PRIMARY KEY AUTOINCREMENT,
-            month_key TEXT NOT NULL,
-            start_time TEXT NOT NULL,
-            duration INTEGER NOT NULL
-        )
-    """)
-
-    # session_participants テーブル
-    await cursor.execute("""
-        CREATE TABLE IF NOT EXISTS session_participants (
-            session_id INTEGER,
-            member_id INTEGER NOT NULL,
-            PRIMARY KEY (session_id, member_id),
-            FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE
-        )
-    """)
-
-    # member_monthly_stats テーブル
-    await cursor.execute("""
-        CREATE TABLE IF NOT EXISTS member_monthly_stats (
-            month_key TEXT NOT NULL,
-            member_id INTEGER NOT NULL,
-            total_duration INTEGER NOT NULL DEFAULT 0,
-            PRIMARY KEY (month_key, member_id)
-        )
-    """)
-
-    # settings テーブル
-    await cursor.execute("""
-        CREATE TABLE IF NOT EXISTS settings (
-            guild_id TEXT PRIMARY KEY,
-            lonely_timeout_minutes INTEGER DEFAULT 180, -- 3時間を分に変換
-            reaction_wait_minutes INTEGER DEFAULT 5
-        )
-    """)
-
-    # インデックス
-    await cursor.execute("CREATE INDEX IF NOT EXISTS idx_sessions_month_key ON sessions (month_key)")
-    await cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_participants_session_id ON session_participants (session_id)")
-    await cursor.execute("CREATE INDEX IF NOT EXISTS idx_session_participants_member_id ON session_participants (member_id)")
-    await cursor.execute("CREATE INDEX IF NOT EXISTS idx_member_monthly_stats_month_key ON member_monthly_stats (month_key)")
-    await cursor.execute("CREATE INDEX IF NOT EXISTS idx_member_monthly_stats_member_id ON member_monthly_stats (member_id)")
-
-    await conn.commit()
-    await conn.close()
+        logger.info(f"データベースファイル '{DB_FILE}' が見つかりませんでした。新規作成します。")
+
+    try:
+        conn = await aiosqlite.connect(DB_FILE)
+        cursor = await conn.cursor()
+
+        # sessions テーブル: 通話セッションの基本情報を記録 (月キー、開始時刻、期間)
+        # id: セッションID (主キー、自動採番)
+        # month_key: 年月 (YYYY-MM 形式)
+        # start_time: セッション開始時刻 (ISO 8601 形式)
+        # duration: セッション期間 (秒単位)
+        await cursor.execute(f"""
+            CREATE TABLE IF NOT EXISTS {constants.TABLE_SESSIONS} (
+                id INTEGER PRIMARY KEY AUTOINCREMENT,
+                {constants.COLUMN_MONTH_KEY} TEXT NOT NULL,
+                {constants.COLUMN_START_TIME} TEXT NOT NULL,
+                duration INTEGER NOT NULL
+            )
+        """)
+        logger.debug(f"テーブル '{constants.TABLE_SESSIONS}' の存在確認または作成を実行しました。")
+
+        # session_participants テーブル: 各セッションの参加メンバーを記録 (sessions テーブルへの外部キーあり)
+        # session_id: セッションID (sessions テーブルの id を参照)
+        # member_id: メンバーID
+        # PRIMARY KEY (session_id, member_id): セッションとメンバーの組み合わせで一意
+        # FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE: sessions のレコード削除時に連動して削除
+        await cursor.execute(f"""
+            CREATE TABLE IF NOT EXISTS {constants.TABLE_SESSION_PARTICIPANTS} (
+                {constants.COLUMN_SESSION_ID} INTEGER,
+                {constants.COLUMN_MEMBER_ID} INTEGER NOT NULL,
+                PRIMARY KEY ({constants.COLUMN_SESSION_ID}, {constants.COLUMN_MEMBER_ID}),
+                FOREIGN KEY ({constants.COLUMN_SESSION_ID}) REFERENCES {constants.TABLE_SESSIONS}(id) ON DELETE CASCADE
+            )
+        """)
+        logger.debug(f"テーブル '{constants.TABLE_SESSION_PARTICIPANTS}' の存在確認または作成を実行しました。")
+
+        # member_monthly_stats テーブル: メンバーごとの月間累計通話時間を記録
+        # month_key: 年月 (YYYY-MM 形式)
+        # member_id: メンバーID
+        # total_duration: 月間累計通話時間 (秒単位)
+        # PRIMARY KEY (month_key, member_id): 年月とメンバーの組み合わせで一意
+        await cursor.execute(f"""
+            CREATE TABLE IF NOT EXISTS {constants.TABLE_MEMBER_MONTHLY_STATS} (
+                {constants.COLUMN_MONTH_KEY} TEXT NOT NULL,
+                {constants.COLUMN_MEMBER_ID} INTEGER NOT NULL,
+                {constants.COLUMN_TOTAL_DURATION} INTEGER NOT NULL DEFAULT {constants.DEFAULT_TOTAL_DURATION},
+                PRIMARY KEY ({constants.COLUMN_MONTH_KEY}, {constants.COLUMN_MEMBER_ID})
+            )
+        """)
+        logger.debug(f"テーブル '{constants.TABLE_MEMBER_MONTHLY_STATS}' の存在確認または作成を実行しました。")
+
+        # settings テーブル: ギルドごとの設定情報を記録 (寝落ち確認のタイムアウト時間など)
+        # guild_id: ギルドID (主キー)
+        # lonely_timeout_minutes: 一人以下の状態が続く時間 (分単位)
+        # reaction_wait_minutes: 寝落ち確認メッセージへの反応を待つ時間 (分単位)
+        await cursor.execute(f"""
+            CREATE TABLE IF NOT EXISTS {constants.TABLE_SETTINGS} (
+                {constants.COLUMN_GUILD_ID} TEXT PRIMARY KEY,
+                {constants.COLUMN_LONELY_TIMEOUT_MINUTES} INTEGER DEFAULT {constants.DEFAULT_LONELY_TIMEOUT_MINUTES},
+                {constants.COLUMN_REACTION_WAIT_MINUTES} INTEGER DEFAULT {constants.DEFAULT_REACTION_WAIT_MINUTES}
+            )
+        """)
+        logger.debug(f"テーブル '{constants.TABLE_SETTINGS}' の存在確認または作成を実行しました。")
+
+        # インデックスの作成 (クエリパフォーマンス向上のため)
+        await cursor.execute(f"CREATE INDEX IF NOT EXISTS idx_sessions_month_key ON {constants.TABLE_SESSIONS} ({constants.COLUMN_MONTH_KEY})")
+        await cursor.execute(f"CREATE INDEX IF NOT EXISTS idx_session_participants_session_id ON {constants.TABLE_SESSION_PARTICIPANTS} ({constants.COLUMN_SESSION_ID})")
+        await cursor.execute(f"CREATE INDEX IF NOT EXISTS idx_session_participants_member_id ON {constants.TABLE_SESSION_PARTICIPANTS} ({constants.COLUMN_MEMBER_ID})")
+        await cursor.execute(f"CREATE INDEX IF NOT EXISTS idx_member_monthly_stats_month_key ON {constants.TABLE_MEMBER_MONTHLY_STATS} ({constants.COLUMN_MONTH_KEY})")
+        await cursor.execute(f"CREATE INDEX IF NOT EXISTS idx_member_monthly_stats_member_id ON {constants.TABLE_MEMBER_MONTHLY_STATS} ({constants.COLUMN_MEMBER_ID})")
+        logger.debug("インデックスの存在確認または作成を実行しました。")
+
+        await conn.commit()
+        logger.debug("データベースの変更をコミットしました。")
+    except Exception as e:
+        logger.error(f"データベース初期化中にエラーが発生しました: {e}")
+        raise # エラーを再送出
+    finally:
+        if conn:
+            await conn.close()
+            logger.debug("データベース接続を閉じました。")
 
     # データベースの初期化が完了したことを通知
-    print(f"データベース '{DB_FILE}' の初期化が完了しました。")
+    logger.info(f"データベース '{DB_FILE}' の初期化が完了しました。")
 
 
 async def get_db_connection():
-    conn = await aiosqlite.connect(DB_FILE)
-    conn.row_factory = aiosqlite.Row # カラム名でアクセスできるようにする
-    return conn
+    """
+    データベース接続を取得し、aiosqlite.Row ファクトリを設定します。
+    """
+    try:
+        conn = await aiosqlite.connect(DB_FILE)
+        conn.row_factory = aiosqlite.Row # カラム名でアクセスできるようにする
+        logger.debug("データベース接続を取得しました。")
+        return conn
+    except Exception as e:
+        logger.error(f"データベース接続の取得中にエラーが発生しました: {e}")
+        raise # エラーを再送出
 
 async def update_member_monthly_stats(month_key, member_id, duration):
-    conn = await get_db_connection()
-    cursor = await conn.cursor()
-    await cursor.execute("""
-        INSERT INTO member_monthly_stats (month_key, member_id, total_duration)
-        VALUES (?, ?, ?)
-        ON CONFLICT(month_key, member_id) DO UPDATE SET
-            total_duration = total_duration + excluded.total_duration
-    """, (month_key, member_id, duration))
-    await conn.commit()
-    await conn.close()
+    """
+    指定された月のメンバーの累計通話時間を更新または挿入します。
+    指定された月とメンバーの組み合わせが既に存在する場合は、total_duration を加算して更新します (ON CONFLICT)。
+    存在しない場合は、新しいレコードを挿入します。
+    """
+    conn = None
+    try:
+        conn = await get_db_connection()
+        cursor = await conn.cursor()
+        await cursor.execute(SQL_UPSERT_MEMBER_MONTHLY_STATS, (month_key, member_id, duration))
+        await conn.commit()
+        logger.info(f"メンバー {member_id} の月間統計を更新しました (月: {month_key}, 期間: {duration})。")
+    except Exception as e:
+        logger.error(f"メンバー月間統計の更新中にエラーが発生しました (月: {month_key}, メンバーID: {member_id}, 期間: {duration}): {e}")
+        # エラー発生時もロールバックは不要 (ON CONFLICT のため)
+    finally:
+        if conn:
+            await conn.close()
+            logger.debug("データベース接続を閉じました。")
+
 
 async def record_voice_session_to_db(session_start, session_duration, participants):
-    conn = await get_db_connection()
-    cursor = await conn.cursor()
+    """
+    通話セッションの情報をデータベースに記録します。
+    sessions テーブルにセッション情報を挿入し、そのセッションに参加したメンバーを session_participants テーブルに挿入します。
+    """
+    conn = None
+    try:
+        conn = await get_db_connection()
+        cursor = await conn.cursor()
+
+        month_key = session_start.strftime("%Y-%m")
+        start_time_iso = session_start.isoformat()
+
+        # sessions テーブルにセッションを挿入
+        await cursor.execute(SQL_INSERT_SESSION, (month_key, start_time_iso, session_duration))
+        session_id = cursor.lastrowid # 挿入されたセッションのIDを取得
+        logger.info(f"新しいセッションを記録しました。セッションID: {session_id}, 開始時刻: {start_time_iso}, 期間: {session_duration}")
+
+        # session_participants テーブルに参加者を挿入
+        if participants:
+            participant_data = [(session_id, p) for p in participants]
+            await cursor.executemany(SQL_INSERT_SESSION_PARTICIPANTS, participant_data)
+            logger.debug(f"セッション {session_id} の参加者 {participants} を記録しました。")
+        else:
+            logger.debug(f"セッション {session_id} に参加者はいませんでした。")
+
+        await conn.commit()
+        logger.debug("データベースの変更をコミットしました。")
+    except Exception as e:
+        logger.error(f"通話セッションの記録中にエラーが発生しました (開始時刻: {session_start}, 期間: {session_duration}, 参加者: {participants}): {e}")
+        if conn:
+            await conn.rollback() # エラー発生時はロールバック
+            logger.warning("データベースの変更をロールバックしました。")
+    finally:
+        if conn:
+            await conn.close()
+            logger.debug("データベース接続を閉じました。")
+
 
-    month_key = session_start.strftime("%Y-%m")
-    start_time_iso = session_start.isoformat()
+# SQL Queries
+# メンバーの総通話時間を取得するクエリ
+SQL_GET_TOTAL_CALL_TIME = f"""
+    SELECT SUM({constants.COLUMN_TOTAL_DURATION}) as total
+    FROM {constants.TABLE_MEMBER_MONTHLY_STATS}
+    WHERE {constants.COLUMN_MEMBER_ID} = ?
+"""
 
-    # sessions テーブルにセッションを挿入
-    await cursor.execute("""
-        INSERT INTO sessions (month_key, start_time, duration)
-        VALUES (?, ?, ?)
-    """, (month_key, start_time_iso, session_duration))
-    session_id = cursor.lastrowid # 挿入されたセッションのIDを取得
+# ギルド設定を取得するクエリ
+SQL_GET_GUILD_SETTINGS = f"SELECT * FROM {constants.TABLE_SETTINGS} WHERE {constants.COLUMN_GUILD_ID} = ?"
 
-    # session_participants テーブルに参加者を挿入
-    participant_data = [(session_id, p) for p in participants]
-    await cursor.executemany("""
-        INSERT INTO session_participants (session_id, member_id)
-        VALUES (?, ?)
-    """, participant_data)
+# settings テーブルへの挿入クエリ
+SQL_UPSERT_SETTINGS_INSERT = f"INSERT INTO {constants.TABLE_SETTINGS} ({constants.COLUMN_GUILD_ID}, {constants.COLUMN_LONELY_TIMEOUT_MINUTES}, {constants.COLUMN_REACTION_WAIT_MINUTES}) VALUES (?, ?, ?)"
+# settings テーブル更新時の SET 句 (lonely_timeout_minutes)
+SQL_UPSERT_SETTINGS_UPDATE_SET_LONELY = f"{constants.COLUMN_LONELY_TIMEOUT_MINUTES} = ?"
+# settings テーブル更新時の SET 句 (reaction_wait_minutes)
+SQL_UPSERT_SETTINGS_UPDATE_SET_REACTION = f"{constants.COLUMN_REACTION_WAIT_MINUTES} = ?"
+# settings テーブル更新時の ON CONFLICT 句
+SQL_UPSERT_SETTINGS_ON_CONFLICT = f"ON CONFLICT({constants.COLUMN_GUILD_ID}) DO UPDATE SET "
+
+# sessions テーブルへの挿入クエリ
+SQL_INSERT_SESSION = f"""
+    INSERT INTO {constants.TABLE_SESSIONS} ({constants.COLUMN_MONTH_KEY}, {constants.COLUMN_START_TIME}, duration)
+    VALUES (?, ?, ?)
+"""
+
+# session_participants テーブルへの挿入クエリ
+SQL_INSERT_SESSION_PARTICIPANTS = f"""
+    INSERT INTO {constants.TABLE_SESSION_PARTICIPANTS} ({constants.COLUMN_SESSION_ID}, {constants.COLUMN_MEMBER_ID})
+    VALUES (?, ?)
+"""
+
+# member_monthly_stats テーブルへの UPSERT (INSERT or UPDATE) クエリ
+# 指定された月とメンバーの組み合わせが存在する場合は total_duration を加算して更新
+SQL_UPSERT_MEMBER_MONTHLY_STATS = f"""
+    INSERT INTO {constants.TABLE_MEMBER_MONTHLY_STATS} ({constants.COLUMN_MONTH_KEY}, {constants.COLUMN_MEMBER_ID}, {constants.COLUMN_TOTAL_DURATION})
+    VALUES (?, ?, ?)
+    ON CONFLICT({constants.COLUMN_MONTH_KEY}, {constants.COLUMN_MEMBER_ID}) DO UPDATE SET
+    {constants.COLUMN_TOTAL_DURATION} = {constants.COLUMN_TOTAL_DURATION} + excluded.{constants.COLUMN_TOTAL_DURATION}
+"""
 
-    await conn.commit()
-    await conn.close()
 
 async def get_total_call_time(member_id):
-    conn = await get_db_connection()
-    cursor = await conn.cursor()
-    await cursor.execute("""
-        SELECT SUM(total_duration) as total
-        FROM member_monthly_stats
-        WHERE member_id = ?
-    """, (member_id,))
-    result = await cursor.fetchone()
-    await conn.close()
-    # 結果がNoneの場合（通話履歴がない場合）は0を返す
-    return result['total'] if result and result['total'] is not None else 0
+    """
+    指定されたメンバーの総通話時間をデータベースから取得します。
+    通話履歴がない場合はデフォルト値 (0) を返します。
+    """
+    conn = None
+    try:
+        conn = await get_db_connection()
+        cursor = await conn.cursor()
+        logger.debug(f"メンバー {member_id} の総通話時間を取得します。")
+        await cursor.execute(SQL_GET_TOTAL_CALL_TIME, (member_id,))
+        result = await cursor.fetchone()
+        # 結果がNoneの場合（通話履歴がない場合）はデフォルト値 (0) を返す
+        total_time = result['total'] if result and result['total'] is not None else constants.DEFAULT_TOTAL_DURATION
+        logger.debug(f"メンバー {member_id} の総通話時間: {total_time}")
+        return total_time
+    except Exception as e:
+        logger.error(f"メンバー {member_id} の総通話時間取得中にエラーが発生しました: {e}")
+        return constants.DEFAULT_TOTAL_DURATION # エラー発生時はデフォルト値を返す
+    finally:
+        if conn:
+            await conn.close()
+            logger.debug("データベース接続を閉じました。")
+
 
 async def get_guild_settings(guild_id):
-    conn = await get_db_connection()
-    cursor = await conn.cursor()
-    await cursor.execute("SELECT * FROM settings WHERE guild_id = ?", (str(guild_id),))
-    settings = await cursor.fetchone()
-    await conn.close()
-    if settings:
-        return settings
-    else:
-        # 設定がない場合はデフォルト値を返す (単位:分)
-        return {"guild_id": str(guild_id), "lonely_timeout_minutes": 1, "reaction_wait_minutes": 1} # テスト用で1分設定
+    """
+    指定されたギルドの設定情報をデータベースから取得します。
+    設定が存在しない場合はデフォルト値を返します。
+    """
+    conn = None
+    try:
+        conn = await get_db_connection()
+        cursor = await conn.cursor()
+        logger.debug(f"ギルド {guild_id} の設定を取得します。")
+        await cursor.execute(SQL_GET_GUILD_SETTINGS, (str(guild_id),))
+        settings = await cursor.fetchone()
+        if settings:
+            logger.debug(f"ギルド {guild_id} の設定が見つかりました: {dict(settings)}")
+            return settings
+        else:
+            logger.debug(f"ギルド {guild_id} の設定が見つかりませんでした。デフォルト値を返します。")
+            # 設定がない場合はデフォルト値を返す (単位:分)
+            return {
+                constants.COLUMN_GUILD_ID: str(guild_id),
+                constants.COLUMN_LONELY_TIMEOUT_MINUTES: constants.DEFAULT_LONELY_TIMEOUT_MINUTES,
+                constants.COLUMN_REACTION_WAIT_MINUTES: constants.DEFAULT_REACTION_WAIT_MINUTES
+            }
+    except Exception as e:
+        logger.error(f"ギルド {guild_id} の設定取得中にエラーが発生しました: {e}")
+        # エラー発生時はデフォルト値を返す
+        return {
+            constants.COLUMN_GUILD_ID: str(guild_id),
+            constants.COLUMN_LONELY_TIMEOUT_MINUTES: constants.DEFAULT_LONELY_TIMEOUT_MINUTES,
+            constants.COLUMN_REACTION_WAIT_MINUTES: constants.DEFAULT_REACTION_WAIT_MINUTES
+        }
+    finally:
+        if conn:
+            await conn.close()
+            logger.debug("データベース接続を閉じました。")
+
 
 async def update_guild_settings(guild_id, lonely_timeout_minutes=None, reaction_wait_minutes=None):
-    conn = await get_db_connection()
-    cursor = await conn.cursor()
-    settings = await get_guild_settings(guild_id)
-
-    update_sql = "INSERT INTO settings (guild_id, lonely_timeout_minutes, reaction_wait_minutes) VALUES (?, ?, ?) ON CONFLICT(guild_id) DO UPDATE SET "
-    params = [str(guild_id)]
-    set_clauses = []
-
-    if lonely_timeout_minutes is not None:
-        set_clauses.append("lonely_timeout_minutes = ?")
-        params.append(lonely_timeout_minutes)
-    else:
-        params.append(settings["lonely_timeout_minutes"])
-
-    if reaction_wait_minutes is not None:
-        set_clauses.append("reaction_wait_minutes = ?")
-        params.append(reaction_wait_minutes)
-    else:
-        params.append(settings["reaction_wait_minutes"])
-
-    update_sql += ", ".join(set_clauses)
-    params.extend(params[1:])
-
-    await cursor.execute(update_sql, params)
-    await conn.commit()
-    await conn.close()
+    """
+    指定されたギルドの設定情報を更新または挿入します (UPSERT)。
+    設定が存在しない場合は新しいレコードを挿入し、存在する場合は指定された値を更新します。
+    """
+    conn = None
+    try:
+        conn = await get_db_connection()
+        cursor = await conn.cursor()
+        logger.info(f"ギルド {guild_id} の設定を更新します。lonely_timeout_minutes: {lonely_timeout_minutes}, reaction_wait_minutes: {reaction_wait_minutes}")
+
+        # 現在の設定を取得して、更新されないパラメータのデフォルト値を決定
+        settings = await get_guild_settings(guild_id)
+
+        set_clauses = []
+        params = [str(guild_id)] # guild_id は ON CONFLICT のために最初に追加
+
+        # INSERT 部分の VALUES (?, ?, ?) に対応するパラメータ
+        insert_params = [str(guild_id)]
+
+        if lonely_timeout_minutes is not None:
+            set_clauses.append(SQL_UPSERT_SETTINGS_UPDATE_SET_LONELY)
+            params.append(lonely_timeout_minutes)
+            insert_params.append(lonely_timeout_minutes)
+        else:
+            insert_params.append(settings[constants.COLUMN_LONELY_TIMEOUT_MINUTES])
+
+        if reaction_wait_minutes is not None:
+            set_clauses.append(SQL_UPSERT_SETTINGS_UPDATE_SET_REACTION)
+            params.append(reaction_wait_minutes)
+            insert_params.append(reaction_wait_minutes)
+        else:
+            insert_params.append(settings[constants.COLUMN_REACTION_WAIT_MINUTES])
+
+        # ON CONFLICT DO UPDATE SET の部分を構築
+        update_sql = SQL_UPSERT_SETTINGS_INSERT + SQL_UPSERT_SETTINGS_ON_CONFLICT
+        update_sql += ", ".join(set_clauses)
+
+        # パラメータの順序を調整: INSERT のパラメータ + UPDATE のパラメータ
+        final_params = insert_params + params[1:] # params[0] は guild_id で重複するため除外
+
+        logger.debug(f"実行するSQL: {update_sql}, パラメータ: {final_params}")
+        await cursor.execute(update_sql, final_params)
+        await conn.commit()
+        logger.info(f"ギルド {guild_id} の設定を更新しました。")
+    except Exception as e:
+        logger.error(f"ギルド {guild_id} の設定更新中にエラーが発生しました: {e}")
+        if conn:
+            await conn.rollback() # エラー発生時はロールバック
+            logger.warning("データベースの変更をロールバックしました。")
+        raise # エラーを再送出
+    finally:
+        if conn:
+            await conn.close()
+            logger.debug("データベース接続を閉じました。")
+
+async def close_db(conn):
+    """
+    データベース接続を閉じます。
+    """
+    if conn:
+        try:
+            await conn.close()
+            logger.debug("データベース接続を閉じました。")
+        except Exception as e:
+            logger.error(f"データベース接続のクローズ中にエラーが発生しました: {e}")
diff --git a/formatters.py b/formatters.py
index 5996e7c..65cb740 100644
--- a/formatters.py
+++ b/formatters.py
@@ -1,13 +1,14 @@
 import datetime
 from zoneinfo import ZoneInfo
+import constants # constants モジュールをインポート
 
 def format_duration(duration_seconds):
     """秒数を時間:分:秒の形式にフォーマットする"""
     seconds = int(duration_seconds)
-    hours, remainder = divmod(seconds, 3600)
-    minutes, seconds = divmod(remainder, 60)
+    hours, remainder = divmod(seconds, constants.SECONDS_PER_HOUR)
+    minutes, seconds = divmod(remainder, constants.SECONDS_PER_MINUTE)
     return f"{hours:02d}:{minutes:02d}:{seconds:02d}"
 
 def convert_utc_to_jst(utc_time):
     """UTC時刻をJSTに変換する"""
-    return utc_time.astimezone(ZoneInfo("Asia/Tokyo"))
+    return utc_time.astimezone(ZoneInfo(constants.TIMEZONE_JST))
diff --git a/main.py b/main.py
index 3edcdcb..6d4ee58 100644
--- a/main.py
+++ b/main.py
@@ -1,53 +1,79 @@
 import discord
-from discord.ext import commands
+from discord.ext import commands, tasks
 import os
-from dotenv import load_dotenv
+import asyncio
+import logging
 
-from database import init_db
+import constants # constants モジュールをインポート
+
+# 他のモジュールのインポート
+from commands import BotCommands
+from tasks import BotTasks
 from voice_events import VoiceEvents, SleepCheckManager
-import utils
-import commands as bot_commands
+from voice_state_manager import VoiceStateManager
 import config
-import voice_state_manager
-import formatters
-import tasks # tasks モジュール全体をインポート
+from database import init_db, close_db
 
-# .envファイルの環境変数を読み込む
-load_dotenv()
+# ロギングの設定
+logging.basicConfig(level=constants.LOGGING_LEVEL, format=constants.LOGGING_FORMAT)
 
-# 環境変数からトークンを取得
+# 設定の読み込み (環境変数からトークンを取得)
 TOKEN = os.getenv('DISCORD_BOT_TOKEN')
+if TOKEN is None:
+    logging.error("DISCORD_BOT_TOKEN 環境変数が設定されていません。")
+    exit(1) # トークンがない場合は終了
+
+# インテントの設定
+intents = discord.Intents.all()
 
-intents = discord.Intents.default()
-intents.voice_states = True
-intents.members = True
-intents.message_content = True
-bot = commands.Bot(command_prefix="!", intents=intents)
+# Botのセットアップ
+bot = commands.Bot(command_prefix=constants.COMMAND_PREFIX, intents=intents)
 
-# --- 起動時処理 ---
 @bot.event
 async def on_ready():
-    await init_db() # データベース初期化をon_readyで行う
-
-    print(f'ログインしました: {bot.user.name}')
-
-    # 依存関係のインスタンス化
-    voice_state_manager_instance = voice_state_manager.VoiceStateManager(bot)
-    sleep_check_manager_instance = SleepCheckManager(bot)
-
-    # Cog のインスタンス化と追加
-    await bot.add_cog(VoiceEvents(bot, sleep_check_manager_instance, voice_state_manager_instance))
-    await bot.add_cog(tasks.BotTasks(bot))
-
-    # BotCommands のインスタンスを作成
-    bot_commands_instance = bot_commands.BotCommands(bot, sleep_check_manager_instance, voice_state_manager_instance)
-
-    # Note: BotCommands Cog を bot.add_cog() で追加するとコマンド同期がうまくいかないため、
+    logging.info(f'Logged in as {bot.user.name}')
+    logging.info(f'Discord.py version: {discord.__version__}')
+
+    # データベースの初期化
+    await init_db()
+    logging.info('Database initialized.')
+
+    # SleepCheckManager と VoiceStateManager のインスタンスを作成
+    sleep_check_manager = SleepCheckManager(bot)
+    voice_state_manager = VoiceStateManager(bot)
+
+    # Cog の追加
+    # SleepCheckManager と VoiceStateManager のインスタンスを作成
+    sleep_check_manager = SleepCheckManager(bot)
+    voice_state_manager = VoiceStateManager(bot)
+
+    # Cog の追加
+    # VoiceEvents Cog は sleep_check_manager と voice_state_manager を必要とする
+    voice_events_cog = VoiceEvents(bot, sleep_check_manager, voice_state_manager)
+    await bot.add_cog(voice_events_cog)
+    logging.info("VoiceEvents Cog を追加しました。")
+
+    # BotCommands のインスタンスを作成 (Cogとしては追加しない)
+    bot_commands_instance = BotCommands(bot, sleep_check_manager, voice_state_manager)
+    logging.info("BotCommands インスタンスを作成しました。")
+
+    # BotTasks Cog は bot_commands_instance を必要とする
+    tasks_cog = BotTasks(bot, bot_commands_instance)
+    await bot.add_cog(tasks_cog)
+    logging.info("BotTasks Cog を追加しました。")
+
+    # 定期実行タスクの開始
+    tasks_cog.send_monthly_stats_task.start()
+    tasks_cog.send_annual_stats_task.start()
+    logging.info("定期実行タスクを開始しました。")
+
+    # コマンドの手動登録と同期
+    # BotCommands Cog を bot.add_cog() で追加するとコマンド同期がうまくいかないため、
     # ここでは BotCommands のインスタンスを作成し、各コマンドを手動でツリーに追加しています。
-
-    # 各ギルドに対してコマンドを手動でツリーに追加し、同期
+    logging.info("全ての参加ギルドに対してコマンドの手動登録と同期を開始します。")
+    synced_guild_count = 0
     for guild in bot.guilds:
-        print(f'接続中のサーバー: {guild.name} (ID: {guild.id})')
+        logging.info(f'ギルド {guild.id} ({guild.name}) のコマンド登録を開始します。')
         try:
             # ギルドコマンドとしてツリーに追加
             bot.tree.add_command(bot_commands_instance.monthly_stats_callback, guild=guild)
@@ -61,19 +87,31 @@ async def on_ready():
 
             # ギルドコマンドを同期
             synced_commands = await bot.tree.sync(guild=guild)
-            print(f'ギルド {guild.name} ({guild.id}) のコマンド同期に成功しました。同期されたコマンド数: {len(synced_commands)}')
+            logging.info(f'ギルド {guild.id} ({guild.name}) のコマンド同期に成功しました。同期されたコマンド数: {len(synced_commands)}')
+            synced_guild_count += 1
 
         except Exception as e:
-            print(f'ギルド {guild.name} ({guild.id}) のコマンド同期に失敗しました: {e}')
+            logging.error(f'ギルド {guild.id} ({guild.name}) のコマンド登録または同期に失敗しました: {e}')
 
-    # タスクの開始
-    # BotTasks Cog の _scheduled_stats タスクを開始
-    bot_tasks_cog = bot.get_cog("BotTasks")
-    if bot_tasks_cog and hasattr(bot_tasks_cog, '_scheduled_stats'):
-        bot_tasks_cog._scheduled_stats.start()
-        print("定期実行タスクを開始しました。")
-    else:
-        print("BotTasks Cog または _scheduled_stats タスクが見つかりませんでした。")
+    logging.info(f'コマンド登録と同期が完了しました。{synced_guild_count} 個のギルドで同期に成功しました。')
+    logging.info('Bot is ready.')
 
-
-bot.run(TOKEN)
+@bot.event
+async def on_disconnect():
+    logging.info('Bot disconnected.')
+    # データベース接続を閉じる
+    # close_db 関数は接続オブジェクトを引数に取るが、ここではグローバルに管理されていないため修正が必要
+    # init_db で取得した接続を保持するか、close_db の実装を変更する必要がある
+    # 一時的にログ出力のみとする
+    logging.warning('Database connection close skipped: close_db requires connection object.')
+    # await close_db() # 修正が必要
+    logging.info('Database connection closed (simulated).')
+
+# Botの実行
+if __name__ == "__main__":
+    try:
+        bot.run(TOKEN)
+    except discord.errors.GatewayNotFound:
+        logging.error("Invalid token was passed.")
+    except Exception as e:
+        logging.error(f"An error occurred during bot execution: {e}")
diff --git a/tasks.py b/tasks.py
index 28cfb08..a6f11ea 100644
--- a/tasks.py
+++ b/tasks.py
@@ -3,64 +3,103 @@ from zoneinfo import ZoneInfo
 from discord.ext import tasks
 import discord # discord モジュールをインポート
 import discord.ext.commands as commands
+import logging # logging モジュールをインポート
 
-
-from commands import create_monthly_stats_embed, create_annual_stats_embed
 import config # config モジュールをインポート
+import constants # constants モジュールをインポート
+
+# ロガーを取得
+logger = logging.getLogger(__name__)
 
 # --- タスクを格納する Cog クラス ---
 class BotTasks(commands.Cog):
-    def __init__(self, bot):
+    def __init__(self, bot, bot_commands_cog):
         self.bot = bot
+        self.bot_commands_cog = bot_commands_cog
+        logger.info("BotTasks Cog initialized.")
         # --- 毎日18時のトリガータスク ---
-        # @tasks.loop デコレータが _scheduled_stats メソッドに適用されているため、__init__ で再度設定する必要はありません。
-
-    @tasks.loop(time=datetime.time(hour=18, minute=0, tzinfo=ZoneInfo("Asia/Tokyo")))
-    async def _scheduled_stats(self):
-        # このメソッドは @tasks.loop デコレータによって自動的にループタスクになります。
-        now = datetime.datetime.now(ZoneInfo("Asia/Tokyo"))
+        # タスクは @tasks.loop デコレータによって定義されます。
+        # __init__ でタスクを開始する必要はありません。setup_tasks 関数で行います。
 
-        # 前月の統計情報送信（毎月1日）
-        if now.day == 1:
-            first_day_current = now.replace(day=1)
-            prev_month_last_day = first_day_current - datetime.timedelta(days=1)
+    # --- 月間統計情報送信タスク ---
+    # 毎日18:00に実行し、日付が1日かチェック
+    @tasks.loop(time=datetime.time(hour=constants.STATS_SEND_HOUR, minute=constants.STATS_SEND_MINUTE, tzinfo=ZoneInfo(constants.TIMEZONE_JST)))
+    async def send_monthly_stats_task(self):
+        now = datetime.datetime.now(ZoneInfo(constants.TIMEZONE_JST))
+        # 実行日が月の1日であるかチェック
+        if now.day == constants.DAY_OF_MONTH_FIRST:
+            logger.info("Starting monthly stats task.")
+            first_day_current = now.replace(day=constants.DAY_OF_MONTH_FIRST)
+            prev_month_last_day = first_day_current - datetime.timedelta(days=1) # timedelta(days=1) は定数化しない
             previous_month = prev_month_last_day.strftime("%Y-%m")
+            logger.debug(f"Calculating stats for previous month: {previous_month}")
 
             # 各ギルドに対して前月の統計情報を送信
             for guild in self.bot.guilds:
                 guild_id = guild.id
+                logger.debug(f"Processing monthly stats for guild {guild_id}")
                 channel_id = config.get_notification_channel_id(guild_id)
                 if channel_id:
                     channel = self.bot.get_channel(channel_id)
                     if channel:
-                        embed, month_display = await create_monthly_stats_embed(guild, previous_month)
+                        logger.debug(f"Sending monthly stats to channel {channel_id} in guild {guild_id}")
+                        embed, month_display = await self.bot_commands_cog._create_monthly_stats_embed(guild, previous_month)
                         if embed:
                             await channel.send(embed=embed)
+                            logger.info(f"Monthly stats sent successfully for {month_display} in guild {guild_id}")
                         else:
+                            logger.info(f"No monthly stats found for {month_display} in guild {guild_id}")
                             embed = discord.Embed(
-                                title=f"【前月の通話統計】",
-                                description=f"{month_display}は通話記録がありませんでした",
-                                color=discord.Color.orange()
+                                title=constants.EMBED_TITLE_MONTHLY_STATS,
+                                description=f"{month_display}{constants.MESSAGE_NO_CALL_RECORDS}",
+                                color=constants.EMBED_COLOR_WARNING
                             )
                             await channel.send(embed=embed)
+                    else:
+                        logger.warning(f"Notification channel {channel_id} not found for guild {guild_id}")
+                else:
+                    logger.info(f"No notification channel set for guild {guild_id}")
+            logger.info("Monthly stats task finished.")
+        else:
+            logger.debug("Monthly stats task skipped: not the first day of the month.")
 
-        # 年間統計情報送信（毎年12月31日）
-        if now.month == 12 and now.day == 31:
+
+    # --- 年間統計情報送信タスク ---
+    # 毎日18:00に実行し、日付が12月31日かチェック
+    @tasks.loop(time=datetime.time(hour=constants.STATS_SEND_HOUR, minute=constants.STATS_SEND_MINUTE, tzinfo=ZoneInfo(constants.TIMEZONE_JST)))
+    async def send_annual_stats_task(self):
+        now = datetime.datetime.now(ZoneInfo(constants.TIMEZONE_JST))
+        # 実行日が12月31日であるかチェック
+        if now.month == constants.MONTH_OF_YEAR_LAST and now.day == constants.DAY_OF_YEAR_LAST:
+            logger.info("Starting annual stats task.")
             year_str = str(now.year)
+            logger.debug(f"Calculating stats for year: {year_str}")
+
             # 各ギルドに対して年間の統計情報を送信
             for guild in self.bot.guilds:
                 guild_id = guild.id
+                logger.debug(f"Processing annual stats for guild {guild_id}")
                 channel_id = config.get_notification_channel_id(guild_id)
                 if channel_id:
                     channel = self.bot.get_channel(channel_id)
                     if channel:
-                        embed, year_display = await create_annual_stats_embed(guild, year_str)
+                        logger.debug(f"Sending annual stats to channel {channel_id} in guild {guild_id}")
+                        embed, year_display = await self.bot_commands_cog._create_annual_stats_embed(guild, year_str)
                         if embed:
                             await channel.send(embed=embed)
+                            logger.info(f"Annual stats sent successfully for {year_display} in guild {guild_id}")
                         else:
+                            logger.info(f"No annual stats found for {year_display} in guild {guild_id}")
                             embed = discord.Embed(
-                                title=f"【年間の通話統計】",
-                                description=f"{year_display}は通話記録がありませんでした",
-                                color=discord.Color.orange()
+                                title=constants.EMBED_TITLE_ANNUAL_STATS,
+                                description=f"{year_display}{constants.MESSAGE_NO_CALL_RECORDS}",
+                                color=constants.EMBED_COLOR_WARNING
                             )
                             await channel.send(embed=embed)
+                    else:
+                        logger.warning(f"Notification channel {channel_id} not found for guild {guild_id}")
+                else:
+                    logger.info(f"No notification channel set for guild {guild_id}")
+            logger.info("Annual stats task finished.")
+        else:
+            logger.debug("Annual stats task skipped: not December 31st.")
diff --git a/utils.py b/utils.py
deleted file mode 100644
index 64cd399..0000000
--- a/utils.py
+++ /dev/null
@@ -1,54 +0,0 @@
-import discord
-from discord.ext import commands
-import os
-from dotenv import load_dotenv
-from zoneinfo import ZoneInfo
-import datetime
-import config
-import formatters
-
-from database import get_total_call_time, update_member_monthly_stats, get_guild_settings
-from config import get_notification_channel_id # get_notification_channel_id をインポート
-# config, voice_state_manager, formatters は後でインポートします
-
-# .envファイルの環境変数を読み込む
-load_dotenv()
-
-
-# --- 10時間達成通知用ヘルパー関数 ---
-async def check_and_notify_milestone(bot, member: discord.Member, guild: discord.Guild, before_total: float, after_total: float):
-    # config モジュールから get_notification_channel_id をインポートする必要があります
-    guild_id = str(guild.id)
-    notification_channel_id = get_notification_channel_id(guild.id) # config から取得
-
-    if notification_channel_id is None:
-        return # 通知先チャンネルが設定されていない場合は何もしない
-
-    notification_channel = bot.get_channel(notification_channel_id)
-    if not notification_channel:
-        print(f"通知チャンネルが見つかりません: ギルドID {guild_id}, チャンネルID {notification_channel_id}")
-        return
-
-    hour_threshold = 10 * 3600 # 10時間 = 36000秒
-    before_milestone = int(before_total // hour_threshold)
-    after_milestone = int(after_total // hour_threshold)
-
-    if after_milestone > before_milestone:
-        achieved_hours = after_milestone * 10
-        embed = discord.Embed(
-            title="🎉 通話時間達成！ 🎉",
-            description=f"{member.mention} さんの累計通話時間が **{achieved_hours}時間** を達成しました！",
-            color=discord.Color.gold()
-        )
-        embed.set_thumbnail(url=member.display_avatar.url)
-        embed.add_field(name="メンバー", value=member.display_name, inline=True)
-        embed.add_field(name="達成時間", value=f"{achieved_hours} 時間", inline=True)
-        embed.add_field(name="現在の総累計時間", value=formatters.format_duration(after_total), inline=False) # Use imported formatters
-        embed.timestamp = datetime.datetime.now(ZoneInfo("Asia/Tokyo"))
-
-        try:
-            await notification_channel.send(embed=embed)
-        except discord.Forbidden:
-            print(f"エラー: チャンネル {notification_channel.name} ({notification_channel_id}) への送信権限がありません。")
-        except Exception as e:
-            print(f"通知送信中にエラーが発生しました: {e}")
diff --git a/voice_events.py b/voice_events.py
index 4c8bbcf..9ff9890 100644
--- a/voice_events.py
+++ b/voice_events.py
@@ -1,17 +1,22 @@
 import discord
 import datetime
 import asyncio
+import logging # logging モジュールをインポート
 from discord.ext import commands # Cog を使用するためにインポート
 
 from database import get_total_call_time, get_guild_settings, update_member_monthly_stats, record_voice_session_to_db
 import config # config モジュールをインポート
 import voice_state_manager # voice_state_manager モジュールをインポート
 import formatters # formatters モジュールをインポート
-import utils # check_and_notify_milestone のために utils をインポート
+import constants # constants モジュールをインポート
+
+# ロガーを取得
+logger = logging.getLogger(__name__)
 
 class SleepCheckManager:
     def __init__(self, bot):
         self.bot = bot
+        logger.info("SleepCheckManager initialized.")
         # 一人以下の状態になった通話チャンネルとその時刻、メンバー、関連タスクを記録する辞書
         # キー: (guild_id, voice_channel_id), 値: {"start_time": datetimeオブジェクト, "member_id": int, "task": asyncio.Task}
         self.lonely_voice_channels = {}
@@ -27,13 +32,13 @@ class SleepCheckManager:
     def add_bot_muted_member(self, member_id: int):
         if member_id not in self.bot_muted_members:
             self.bot_muted_members.append(member_id)
-            print(f"メンバー {member_id} をbot_muted_membersに追加しました。")
+            logger.info(f"メンバー {member_id} をbot_muted_membersに追加しました。")
 
     # bot_muted_members からメンバーを削除するヘルパー関数
     def remove_bot_muted_member(self, member_id: int):
         if member_id in self.bot_muted_members:
             self.bot_muted_members.remove(member_id)
-            print(f"メンバー {member_id} をbot_muted_membersから削除しました。")
+            logger.info(f"メンバー {member_id} をbot_muted_membersから削除しました。")
 
     # lonely_voice_channels にチャンネルを追加するヘルパー関数
     def add_lonely_channel(self, guild_id: int, channel_id: int, member_id: int, task: asyncio.Task):
@@ -43,7 +48,7 @@ class SleepCheckManager:
             "member_id": member_id,
             "task": task
         }
-        print(f"チャンネル {channel_id} ({guild_id}) が一人以下になりました。メンバー: {member_id}")
+        logger.info(f"チャンネル {channel_id} ({guild_id}) が一人以下になりました。メンバー: {member_id}")
 
     # lonely_voice_channels からチャンネルを削除するヘルパー関数
     def remove_lonely_channel(self, guild_id: int, channel_id: int, cancel_task: bool = True):
@@ -51,24 +56,31 @@ class SleepCheckManager:
         if key in self.lonely_voice_channels:
             if cancel_task and self.lonely_voice_channels[key]["task"] and not self.lonely_voice_channels[key]["task"].cancelled():
                 self.lonely_voice_channels[key]["task"].cancel()
+                logger.debug(f"チャンネル {channel_id} ({guild_id}) の一人以下の状態タスクをキャンセルしました。")
             self.lonely_voice_channels.pop(key)
-            print(f"チャンネル {channel_id} ({guild_id}) の一人以下の状態を解除しました。")
+            logger.info(f"チャンネル {channel_id} ({guild_id}) の一人以下の状態を解除しました。")
 
     # --- 寝落ち確認とミュート処理 ---
     async def check_lonely_channel(self, guild_id: int, channel_id: int, member_id: int):
-        await asyncio.sleep(await get_lonely_timeout_seconds(guild_id)) # 設定された時間待機
+        logger.info(f"チャンネル {channel_id} ({guild_id}) の一人以下の状態を確認開始します。メンバー: {member_id}")
+        timeout_seconds = await self._get_lonely_timeout_seconds(guild_id)
+        logger.debug(f"設定されたタイムアウト時間: {timeout_seconds} 秒")
+        await asyncio.sleep(timeout_seconds) # 設定された時間待機
 
         # 再度チャンネルの状態を確認
         guild = self.bot.get_guild(guild_id)
         if not guild:
+            logger.warning(f"ギルド {guild_id} が見つかりませんでした。一人以下の状態確認を終了します。")
             return
         channel = guild.get_channel(channel_id)
         # チャンネルが存在しない、またはタイムアウトしたメンバーがチャンネルにいない場合は処理しない
         if not channel or member_id not in [m.id for m in channel.members]:
+            logger.info(f"チャンネル {channel_id} が存在しないか、メンバー {member_id} がチャンネルにいません。一人以下の状態確認を終了します。")
             self.remove_lonely_channel(guild_id, channel_id, cancel_task=False) # タスク自体は完了しているのでキャンセルは不要
             return
 
         # チャンネルに一人だけ残っている、または複数人だが最初に一人になったメンバーがまだいる場合
+        logger.info(f"チャンネル {channel_id} ({guild_id}) が一人以下の状態が継続しています。寝落ち確認メッセージを送信します。")
         # 寝落ち確認メッセージを送信
         notification_channel_id = config.get_notification_channel_id(guild_id) # config から取得
         if notification_channel_id:
@@ -77,35 +89,38 @@ class SleepCheckManager:
                 lonely_member = guild.get_member(member_id)
                 if lonely_member:
                     embed = discord.Embed(
-                        title="寝落ちミュート",
-                        description=f"{lonely_member.mention} さん、{channel.name} chで一人になってから時間が経ちました。\n寝落ちしていませんか？反応がない場合、自動でサーバーミュートします。\nミュートをキャンセルする場合は、 :white_check_mark: を押してください。",
-                        color=discord.Color.orange()
+                        title=constants.EMBED_TITLE_SLEEP_CHECK,
+                        description=f"{lonely_member.mention}{constants.EMBED_DESCRIPTION_SLEEP_CHECK.format(channel_name=channel.name)}",
+                        color=constants.EMBED_COLOR_WARNING
                     )
                     try:
                         message = await notification_channel.send(embed=embed)
-                        await message.add_reaction("✅") # :white_check_mark: 絵文字を追加
+                        await message.add_reaction(constants.REACTION_EMOJI_SLEEP_CHECK) # :white_check_mark: 絵文字を追加
+                        logger.info(f"寝落ち確認メッセージをチャンネル {notification_channel_id} に送信しました。メッセージID: {message.id}")
 
                         # リアクション監視タスクを開始
                         reaction_task = asyncio.create_task(self.wait_for_reaction(message.id, member_id, guild_id, channel_id))
                         self.sleep_check_messages[message.id] = {"member_id": member_id, "task": reaction_task}
+                        logger.debug(f"リアクション監視タスクを開始しました。メッセージID: {message.id}")
 
                     except discord.Forbidden:
-                        print(f"エラー: チャンネル {notification_channel.name} ({notification_channel_id}) への送信権限がありません。")
+                        logger.error(f"エラー: チャンネル {notification_channel.name} ({notification_channel_id}) への送信権限がありません。")
                     except Exception as e:
-                        print(f"寝落ち確認メッセージ送信中にエラーが発生しました: {e}")
+                        logger.error(f"寝落ち確認メッセージ送信中にエラーが発生しました: {e}")
                 else:
+                     logger.warning(f"メンバー {member_id} が見つかりませんでした。一人以下の状態管理から削除します。")
                      # メンバーが見つからない場合も状態管理から削除
                      key = (guild_id, channel_id)
                      if key in self.lonely_voice_channels:
                         self.lonely_voice_channels.pop(key)
             else:
-                print(f"通知チャンネルが見つかりません: ギルドID {guild_id}")
+                logger.warning(f"通知チャンネルが見つかりません: ギルドID {guild_id}。一人以下の状態管理から削除します。")
                 # 通知チャンネルがない場合も状態管理から削除
                 key = (guild_id, channel_id)
                 if key in self.lonely_voice_channels:
                     self.lonely_voice_channels.pop(key)
         else:
-            print(f"ギルド {guild.name} ({guild_id}) の通知チャンネルが設定されていません。寝落ち確認メッセージを送信できません。")
+            logger.warning(f"ギルド {guild.name} ({guild_id}) の通知チャンネルが設定されていません。寝落ち確認メッセージを送信できません。一人以下の状態管理から削除します。")
             # 通知チャンネルが設定されていない場合も状態管理から削除
             key = (guild_id, channel_id)
             if key in self.lonely_voice_channels:
@@ -113,16 +128,18 @@ class SleepCheckManager:
 
 
     async def wait_for_reaction(self, message_id: int, member_id: int, guild_id: int, channel_id: int):
+        logger.info(f"メッセージ {message_id} へのリアクション監視を開始します。メンバー: {member_id}")
         settings = await get_guild_settings(guild_id)
-        wait_seconds = settings["reaction_wait_minutes"] * 60
+        wait_seconds = settings["reaction_wait_minutes"] * constants.SECONDS_PER_MINUTE
+        logger.debug(f"設定されたリアクション待機時間: {wait_seconds} 秒")
 
         try:
             # 指定された絵文字、ユーザーからのリアクションを待つ
             def check(reaction, user):
-                return user.id == member_id and str(reaction.emoji) == '✅' and reaction.message.id == message_id
+                return user.id == member_id and str(reaction.emoji) == constants.REACTION_EMOJI_SLEEP_CHECK and reaction.message.id == message_id
 
             await self.bot.wait_for('reaction_add', timeout=wait_seconds, check=check)
-            print(f"メンバー {member_id} がメッセージ {message_id} に反応しました。ミュート処理をキャンセルします。")
+            logger.info(f"メンバー {member_id} がメッセージ {message_id} に反応しました。ミュート処理をキャンセルします。")
             guild = self.bot.get_guild(guild_id)
             notification_channel_id = config.get_notification_channel_id(guild_id) # config から取得
             if guild and notification_channel_id:
@@ -131,24 +148,25 @@ class SleepCheckManager:
                     try:
                         member = guild.get_member(member_id)
                         if member:
-                            embed = discord.Embed(title="寝落ちミュート", description=f"{member.mention} さんが反応しました。\nサーバーミュートをキャンセルしました。", color=discord.Color.green())
+                            embed = discord.Embed(title=constants.EMBED_TITLE_SLEEP_CHECK, description=f"{member.mention}{constants.EMBED_DESCRIPTION_SLEEP_CHECK_CANCEL}", color=constants.EMBED_COLOR_SUCCESS)
                             await notification_channel.send(embed=embed)
+                            logger.info(f"ミュートキャンセルメッセージをチャンネル {notification_channel.id} に送信しました。")
                     except discord.Forbidden:
-                        print(f"エラー: チャンネル {notification_channel.name} ({notification_channel.id}) への送信権限がありません。")
+                        logger.error(f"エラー: チャンネル {notification_channel.name} ({notification_channel.id}) への送信権限がありません。")
                     except Exception as e:
-                        print(f"ミュートキャンセルメッセージ送信中にエラーが発生しました: {e}")
+                        logger.error(f"ミュートキャンセルメッセージ送信中にエラーが発生しました: {e}")
 
 
         except asyncio.TimeoutError:
             # タイムアウトした場合、ミュート処理を実行
-            print(f"メッセージ {message_id} への反応がありませんでした。メンバー {member_id} をミュートします。")
+            logger.info(f"メッセージ {message_id} への反応がありませんでした。メンバー {member_id} をミュートします。")
             guild = self.bot.get_guild(guild_id)
             if guild:
                 member = guild.get_member(member_id)
                 if member:
                     try:
-                        await member.edit(mute=True, deafen=False)
-                        print(f"メンバー {member.display_name} ({member.id}) をミュートしました。")
+                        await member.edit(mute=True, deafen=True)
+                        logger.info(f"メンバー {member.display_name} ({member.id}) をミュートしました。")
                         # ボットがミュートしたメンバーを記録
                         self.add_bot_muted_member(member.id)
 
@@ -157,35 +175,39 @@ class SleepCheckManager:
                             notification_channel = self.bot.get_channel(notification_channel_id)
                             if notification_channel:
                                 try:
-                                    embed = discord.Embed(title="寝落ちミュート", description=f"{member.mention} さんからの反応がなかったため、サーバーミュートしました。\n再入室するとサーバーミュートが解除されます。", color=discord.Color.red())
+                                    embed = discord.Embed(title=constants.EMBED_TITLE_SLEEP_CHECK, description=f"{member.mention}{constants.EMBED_DESCRIPTION_SLEEP_CHECK_MUTE}", color=constants.EMBED_COLOR_ERROR)
                                     await notification_channel.send(embed=embed)
+                                    logger.info(f"ミュート実行メッセージをチャンネル {notification_channel.id} に送信しました。")
                                 except discord.Forbidden:
-                                    print(f"エラー: チャンネル {notification_channel.name} ({notification_channel.id}) への送信権限がありません。")
+                                    logger.error(f"エラー: チャンネル {notification_channel.name} ({notification_channel.id}) への送信権限がありません。")
                                 except Exception as e:
-                                    print(f"ミュート実行メッセージ送信中にエラーが発生しました: {e}")
+                                    logger.error(f"ミュート実行メッセージ送信中にエラーが発生しました: {e}")
 
                     except discord.Forbidden:
-                        print(f"エラー: メンバー {member.display_name} ({member_id}) をミュートする権限がありません。")
+                        logger.error(f"エラー: メンバー {member.display_name} ({member_id}) のミュートを解除する権限がありません。")
                     except Exception as e:
-                        print(f"メンバーミュート中にエラーが発生しました: {e}")
+                        logger.error(f"メンバーミュート解除中にエラーが発生しました: {e}")
                 else:
-                    print(f"メンバー {member_id} が見つかりませんでした。")
+                    logger.warning(f"メンバー {member_id} が見つかりませんでした。")
             else:
-                print(f"ギルド {guild_id} が見つかりませんでした。")
+                logger.warning(f"ギルド {guild_id} が見つかりませんでした。")
 
         finally:
             # 処理が完了したら、一時的な記録から削除
             if message_id in self.sleep_check_messages:
                 self.sleep_check_messages.pop(message_id)
+                logger.debug(f"メッセージ {message_id} をsleep_check_messagesから削除しました。")
             # チャンネルの状態管理からも削除（ミュートされたか反応があったかで一人以下の状態は終了とみなす）
             key = (guild_id, channel_id)
             if key in self.lonely_voice_channels:
                  self.lonely_voice_channels.pop(key)
+                 logger.debug(f"チャンネル {channel_id} ({guild_id}) をlonely_voice_channelsから削除しました。")
 
+    # get_lonely_timeout_seconds を SleepCheckManager のメソッドとして移動
+    async def _get_lonely_timeout_seconds(self, guild_id):
+        settings = await get_guild_settings(guild_id)
+        return settings[constants.COLUMN_LONELY_TIMEOUT_MINUTES] * constants.SECONDS_PER_MINUTE # 分を秒に変換
 
-async def get_lonely_timeout_seconds(guild_id):
-    settings = await get_guild_settings(guild_id)
-    return settings["lonely_timeout_minutes"] * 60 # 分を秒に変換
 
 # --- イベントハンドラ ---
 
@@ -194,227 +216,278 @@ class VoiceEvents(commands.Cog):
         self.bot = bot
         self.sleep_check_manager = sleep_check_manager
         self.voice_state_manager = voice_state_manager
+        logger.info("VoiceEvents Cog initialized.")
+
+    # --- 10時間達成通知用ヘルパー関数 ---
+    async def _check_and_notify_milestone(self, member: discord.Member, guild: discord.Guild, before_total: float, after_total: float):
+        logger.info(f"マイルストーン通知を確認します。メンバー: {member.id}, ギルド: {guild.id}, Before: {before_total}, After: {after_total}")
+        # config モジュールから get_notification_channel_id をインポートする必要があります
+        guild_id = str(guild.id)
+        notification_channel_id = config.get_notification_channel_id(guild.id) # config から取得
+
+        if notification_channel_id is None:
+            logger.debug(f"ギルド {guild_id} の通知先チャンネルが設定されていません。マイルストーン通知はスキップします。")
+            return # 通知先チャンネルが設定されていない場合は何もしない
+
+        notification_channel = self.bot.get_channel(notification_channel_id)
+        if not notification_channel:
+            logger.warning(f"通知チャンネルが見つかりません: ギルドID {guild_id}, チャンネルID {notification_channel_id}")
+            return
 
-    @commands.Cog.listener()
-    async def on_voice_state_update(self, member, before, after):
-        guild_id = member.guild.id
-        now = datetime.datetime.now(datetime.timezone.utc)
-
-        channel_before = before.channel
-        channel_after = after.channel
+        hour_threshold = constants.MILESTONE_THRESHOLD_SECONDS
+        before_milestone = int(before_total // hour_threshold)
+        after_milestone = int(after_total // hour_threshold)
+        logger.debug(f"Before milestone: {before_milestone}, After milestone: {after_milestone}")
+
+        if after_milestone > before_milestone:
+            achieved_hours = after_milestone * 10 # 10時間ごとのマイルストーンなので 10 を乗算
+            logger.info(f"メンバー {member.id} が {achieved_hours} 時間のマイルストーンを達成しました。")
+            embed = discord.Embed(
+                title=constants.EMBED_TITLE_MILESTONE,
+                description=constants.EMBED_DESCRIPTION_MILESTONE.format(member=member, achieved_hours=achieved_hours),
+                color=constants.EMBED_COLOR_MILESTONE
+            )
+            embed.set_thumbnail(url=member.display_avatar.url)
+            embed.add_field(name=constants.EMBED_FIELD_MEMBER, value=member.display_name, inline=True)
+            embed.add_field(name=constants.EMBED_FIELD_ACHIEVED_TIME, value=f"{achieved_hours} 時間", inline=True)
+            embed.add_field(name=constants.EMBED_FIELD_CURRENT_TOTAL, value=formatters.format_duration(after_total), inline=False) # Use imported formatters
+            embed.timestamp = datetime.datetime.now(constants.TIMEZONE_JST)
+
+            try:
+                await notification_channel.send(embed=embed)
+                logger.info(f"マイルストーン通知をチャンネル {notification_channel_id} に送信しました。")
+            except discord.Forbidden:
+                logger.error(f"エラー: チャンネル {notification_channel.name} ({notification_channel_id}) への送信権限がありません。")
+            except Exception as e:
+                logger.error(f"通知送信中にエラーが発生しました: {e}")
+        else:
+            logger.debug("マイルストーン達成なし。")
 
-        # SleepCheckManager のロジックはここに残す
-        key_before = (guild_id, channel_before.id) if channel_before else None
-        key_after = (guild_id, channel_after.id) if channel_after else None
-
-        # チャンネルから退出した場合
-        if channel_before is not None and channel_after is None:
-            # 退室したメンバーに関連付けられた寝落ち確認タスクがあればキャンセル
-            message_ids_to_remove = []
-            for message_id, data in self.sleep_check_manager.sleep_check_messages.items():
-                if data["member_id"] == member.id:
-                    if data["task"] and not data["task"].cancelled():
-                        data["task"].cancel()
-                        print(f"メンバー {member.id} の退出により、メッセージ {message_id} のリアクション監視タスクをキャンセルしました。")
-                    message_ids_to_remove.append(message_id)
-
-            for message_id in message_ids_to_remove:
-                self.sleep_check_manager.sleep_check_messages.pop(message_id)
-                print(f"メッセージ {message_id} をsleep_check_messagesから削除しました。")
-
-            # 退室したチャンネルに誰もいなくなった場合、一人以下の状態を解除
-            if channel_before is not None and len(channel_before.members) == 0:
-                self.sleep_check_manager.remove_lonely_channel(guild_id, channel_before.id)
-            # 退室したチャンネルに一人だけ残った場合、そのメンバーに対して一人以下の状態を開始
-            elif channel_before is not None and len(channel_before.members) == 1:
-                lonely_member = channel_before.members[0]
-                if key_before not in self.sleep_check_manager.lonely_voice_channels and lonely_member.id not in self.sleep_check_manager.bot_muted_members:
-                    task = asyncio.create_task(self.sleep_check_manager.check_lonely_channel(guild_id, channel_before.id, lonely_member.id))
-                    self.sleep_check_manager.add_lonely_channel(guild_id, channel_before.id, lonely_member.id, task)
-
-            # VoiceStateManager に処理を委譲し、統計更新が必要なデータを取得
-            ended_sessions_data = await self.voice_state_manager.handle_member_leave(member, channel_before)
-            # VoiceStateManager から統計更新が必要なデータが返された場合、各メンバーごとに処理
-            for member_id, duration, join_time in ended_sessions_data:
-                before_total = await get_total_call_time(member_id)
-                month_key = join_time.strftime("%Y-%m")
-                await update_member_monthly_stats(month_key, member_id, duration)
-                after_total = await get_total_call_time(member_id)
-                m_obj = member.guild.get_member(member_id) if member.guild else None
-                if m_obj:
-                    await utils.check_and_notify_milestone(self.bot, m_obj, member.guild, before_total, after_total)
-
-
-        # チャンネルに入室した場合
-        elif channel_before is None and channel_after is not None:
-            # 入室したチャンネルが一人以下になった場合、そのメンバーに対して一人以下の状態を開始
-            if len(channel_after.members) == 1:
-                lonely_member = channel_after.members[0]
-                if key_after not in self.sleep_check_manager.lonely_voice_channels and lonely_member.id not in self.sleep_check_manager.bot_muted_members:
-                    task = asyncio.create_task(self.sleep_check_manager.check_lonely_channel(guild_id, channel_after.id, lonely_member.id))
-                    self.sleep_check_manager.add_lonely_channel(guild_id, channel_after.id, lonely_member.id, task)
-            # 入室したチャンネルが複数人になった場合、一人以下の状態を解除
-            elif len(channel_after.members) > 1:
+    # チャンネルに入室した場合の処理
+    async def _handle_join(self, member, channel_after):
+        logger.info(f"メンバー {member.id} がチャンネル {channel_after.id} ({channel_after.name}) に入室しました。")
+        guild_id = member.guild.id
+        key_after = (guild_id, channel_after.id)
+
+        # 入室したチャンネルが一人以下になった場合、そのメンバーに対して一人以下の状態を開始
+        if len(channel_after.members) == 1:
+            lonely_member = channel_after.members[0]
+            if key_after not in self.sleep_check_manager.lonely_voice_channels and lonely_member.id not in self.sleep_check_manager.bot_muted_members:
+                logger.debug(f"チャンネル {channel_after.id} ({guild_id}) が一人以下になりました。寝落ち確認を開始します。メンバー: {lonely_member.id}")
+                task = asyncio.create_task(self.sleep_check_manager.check_lonely_channel(guild_id, channel_after.id, lonely_member.id))
+                self.sleep_check_manager.add_lonely_channel(guild_id, channel_after.id, lonely_member.id, task)
+        # 入室したチャンネルが複数人になった場合、一人以下の状態を解除
+        elif len(channel_after.members) > 1:
+            if key_after in self.sleep_check_manager.lonely_voice_channels:
+                logger.debug(f"チャンネル {channel_after.id} ({guild_id}) に複数人が入室しました。一人以下の状態を解除します。")
                 self.sleep_check_manager.remove_lonely_channel(guild_id, channel_after.id)
 
-            # VoiceStateManager に処理を委譲
-            await self.voice_state_manager.handle_member_join(member, channel_after)
-
-            # ボットによってミュートされたメンバーが再入室した場合、ミュートを解除
-            if member.id in self.sleep_check_manager.bot_muted_members:
-                async def unmute_after_delay(m: discord.Member):
-                    await asyncio.sleep(1) # 1秒待機
-                    try:
-                        await m.edit(mute=False, deafen=False)
-                        self.sleep_check_manager.remove_bot_muted_member(m.id)
-                        print(f"メンバー {m.display_name} ({m.id}) が再入室したためミュートを解除しました。")
-
-                        notification_channel_id = config.get_notification_channel_id(m.guild.id)
-                        if notification_channel_id:
-                            notification_channel = self.bot.get_channel(notification_channel_id)
-                            if notification_channel:
-                                try:
-                                    embed = discord.Embed(title="寝落ちミュート", description=f"{m.mention} さんが再入室したため、サーバーミュートを解除しました。", color=discord.Color.green())
-                                    await notification_channel.send(embed=embed)
-                                except discord.Forbidden:
-                                    print(f"エラー: チャンネル {notification_channel.name} ({notification_channel.id}) への送信権限がありません。")
-                                except Exception as e:
-                                    print(f"再入室時ミュート解除メッセージ送信中にエラーが発生しました: {e}")
-
-                    except discord.Forbidden:
-                        print(f"エラー: メンバー {m.display_name} ({m.id}) のミュートを解除する権限がありません。")
-                    except Exception as e:
-                        print(f"メンバーミュート解除中にエラーが発生しました: {e}")
-
-                asyncio.create_task(unmute_after_delay(member))
-
+        # VoiceStateManager に処理を委譲
+        await self.voice_state_manager.handle_member_join(member, channel_after)
+        logger.debug(f"VoiceStateManager.handle_member_join 処理完了。メンバー: {member.id}, チャンネル: {channel_after.id}")
+
+        # ボットによってミュートされたメンバーが再入室した場合、ミュートを解除
+        if member.id in self.sleep_check_manager.bot_muted_members:
+            logger.info(f"ボットによってミュートされたメンバー {member.id} が再入室しました。ミュート解除をスケジュールします。")
+            async def unmute_after_delay(m: discord.Member):
+                logger.debug(f"メンバー {m.id} のミュート解除遅延処理を開始します。")
+                # チャンネルの状態変化が完全に反映されるのを待つため、少し遅延させる
+                await asyncio.sleep(constants.UNMUTE_DELAY_SECONDS)
+                try:
+                    await m.edit(mute=False, deafen=False)
+                    self.sleep_check_manager.remove_bot_muted_member(m.id)
+                    logger.info(f"メンバー {m.display_name} ({m.id}) が再入室したためミュートを解除しました。")
+
+                    notification_channel_id = config.get_notification_channel_id(m.guild.id)
+                    if notification_channel_id:
+                        notification_channel = self.bot.get_channel(notification_channel_id)
+                        if notification_channel:
+                            try:
+                                embed = discord.Embed(title=constants.EMBED_TITLE_SLEEP_CHECK, description=f"{m.mention}{constants.EMBED_DESCRIPTION_UNMUTE_ON_REJOIN}", color=constants.EMBED_COLOR_SUCCESS)
+                                await notification_channel.send(embed=embed)
+                                logger.info(f"再入室時ミュート解除メッセージをチャンネル {notification_channel.id} に送信しました。")
+                            except discord.Forbidden:
+                                logger.error(f"エラー: チャンネル {notification_channel.name} ({notification_channel.id}) への送信権限がありません。")
+                            except Exception as e:
+                                logger.error(f"再入室時ミュート解除メッセージ送信中にエラーが発生しました: {e}")
+
+                except discord.Forbidden:
+                    logger.error(f"エラー: メンバー {m.display_name} ({m.id}) のミュートを解除する権限がありません。")
+                except Exception as e:
+                    logger.error(f"メンバーミュート解除中にエラーが発生しました: {e}")
+                logger.debug(f"メンバー {m.id} のミュート解除遅延処理が完了しました。")
+
+            asyncio.create_task(unmute_after_delay(member))
+
+    # チャンネルから退出した場合の処理
+    async def _handle_leave(self, member, channel_before):
+        logger.info(f"メンバー {member.id} がチャンネル {channel_before.id} ({channel_before.name}) から退出しました。")
+        guild_id = member.guild.id
+        key_before = (guild_id, channel_before.id)
+
+        # 退室したメンバーに関連付けられた寝落ち確認タスクがあればキャンセル
+        message_ids_to_remove = []
+        for message_id, data in self.sleep_check_manager.sleep_check_messages.items():
+            if data["member_id"] == member.id:
+                if data["task"] and not data["task"].cancelled():
+                    data["task"].cancel()
+                    logger.info(f"メンバー {member.id} の退出により、メッセージ {message_id} のリアクション監視タスクをキャンセルしました。")
+                message_ids_to_remove.append(message_id)
+
+        for message_id in message_ids_to_remove:
+            self.sleep_check_manager.sleep_check_messages.pop(message_id)
+            logger.debug(f"メッセージ {message_id} をsleep_check_messagesから削除しました。")
+
+        # 退室したチャンネルに誰もいなくなった場合、一人以下の状態を解除
+        if channel_before is not None and len(channel_before.members) == 0:
+            if key_before in self.sleep_check_manager.lonely_voice_channels:
+                logger.debug(f"チャンネル {channel_before.id} ({guild_id}) に誰もいなくなりました。一人以下の状態を解除します。")
+                self.sleep_check_manager.remove_lonely_channel(guild_id, channel_before.id)
+        # 退室したチャンネルに一人だけ残った場合、そのメンバーに対して一人以下の状態を開始
+        elif channel_before is not None and len(channel_before.members) == 1:
+            lonely_member = channel_before.members[0]
+            if key_before not in self.sleep_check_manager.lonely_voice_channels and lonely_member.id not in self.sleep_check_manager.bot_muted_members:
+                logger.debug(f"チャンネル {channel_before.id} ({guild_id}) に一人だけ残りました。寝落ち確認を開始します。メンバー: {lonely_member.id}")
+                task = asyncio.create_task(self.sleep_check_manager.check_lonely_channel(guild_id, channel_before.id, lonely_member.id))
+                self.sleep_check_manager.add_lonely_channel(guild_id, channel_before.id, lonely_member.id, task)
+
+        # VoiceStateManager に処理を委譲し、統計更新が必要なデータを取得
+        ended_sessions_data = await self.voice_state_manager.handle_member_leave(member, channel_before)
+        logger.debug(f"VoiceStateManager.handle_member_leave 処理完了。メンバー: {member.id}, チャンネル: {channel_before.id}. 終了セッション数: {len(ended_sessions_data)}")
+        # VoiceStateManager から統計更新が必要なデータが返された場合、各メンバーごとに処理
+        for member_id, duration, join_time in ended_sessions_data:
+            logger.debug(f"統計更新処理を開始します。メンバー: {member_id}, 期間: {duration}, 参加時刻: {join_time}")
+            before_total = await get_total_call_time(member_id)
+            month_key = join_time.strftime("%Y-%m")
+            await update_member_monthly_stats(month_key, member_id, duration)
+            after_total = await get_total_call_time(member_id)
+            logger.debug(f"メンバー {member_id} の月間統計を更新しました。Before Total: {before_total}, After Total: {after_total}")
+            m_obj = member.guild.get_member(member_id) if member.guild else None
+            if m_obj:
+                await self._check_and_notify_milestone(m_obj, member.guild, before_total, after_total)
+
+    # チャンネル間を移動した場合の処理
+    async def _handle_move(self, member, channel_before, channel_after):
+        logger.info(f"メンバー {member.id} がチャンネル {channel_before.id} ({channel_before.name}) からチャンネル {channel_after.id} ({channel_after.name}) に移動しました。")
+        guild_id = member.guild.id
+        key_before = (guild_id, channel_before.id)
+        key_after = (guild_id, channel_after.id)
 
-        # チャンネル間を移動した場合
-        elif channel_before is not None and channel_after is not None and channel_before != channel_after:
-            # 移動元チャンネルに誰もいなくなった場合、一人以下の状態を解除
-            if len(channel_before.members) == 0:
+        # 移動元チャンネルに誰もいなくなった場合、一人以下の状態を解除
+        if len(channel_before.members) == 0:
+            if key_before in self.sleep_check_manager.lonely_voice_channels:
+                logger.debug(f"移動元チャンネル {channel_before.id} ({guild_id}) に誰もいなくなりました。一人以下の状態を解除します。")
                 self.sleep_check_manager.remove_lonely_channel(guild_id, channel_before.id)
-            # 移動元チャンネルに一人だけ残った場合、そのメンバーに対して一人以下の状態を開始
-            elif len(channel_before.members) == 1:
-                lonely_member = channel_before.members[0]
-                if key_before not in self.sleep_check_manager.lonely_voice_channels and lonely_member.id not in self.sleep_check_manager.bot_muted_members:
-                    task = asyncio.create_task(self.sleep_check_manager.check_lonely_channel(guild_id, channel_before.id, lonely_member.id))
-                    self.sleep_check_manager.add_lonely_channel(guild_id, channel_before.id, lonely_member.id, task)
-
-            # 移動先チャンネルが一人以下になった場合、そのメンバーに対して一人以下の状態を開始
-            if len(channel_after.members) == 1:
-                lonely_member = channel_after.members[0]
-                if key_after not in self.sleep_check_manager.lonely_voice_channels and lonely_member.id not in self.sleep_check_manager.bot_muted_members:
-                    task = asyncio.create_task(self.sleep_check_manager.check_lonely_channel(guild_id, channel_after.id, lonely_member.id))
-                    self.sleep_check_manager.add_lonely_channel(guild_id, channel_after.id, lonely_member.id, task)
-            # 移動先チャンネルが複数人になった場合、一人以下の状態を解除
-            elif len(channel_after.members) > 1:
+        # 移動元チャンネルに一人だけ残った場合、そのメンバーに対して一人以下の状態を開始
+        elif len(channel_before.members) == 1:
+            lonely_member = channel_before.members[0]
+            if key_before not in self.sleep_check_manager.lonely_voice_channels and lonely_member.id not in self.sleep_check_manager.bot_muted_members:
+                logger.debug(f"移動元チャンネル {channel_before.id} ({guild_id}) に一人だけ残りました。寝落ち確認を開始します。メンバー: {lonely_member.id}")
+                task = asyncio.create_task(self.sleep_check_manager.check_lonely_channel(guild_id, channel_before.id, lonely_member.id))
+                self.sleep_check_manager.add_lonely_channel(guild_id, channel_before.id, lonely_member.id, task)
+
+        # 移動先チャンネルが一人以下になった場合、そのメンバーに対して一人以下の状態を開始
+        if len(channel_after.members) == 1:
+            lonely_member = channel_after.members[0]
+            if key_after not in self.sleep_check_manager.lonely_voice_channels and lonely_member.id not in self.sleep_check_manager.bot_muted_members:
+                logger.debug(f"移動先チャンネル {channel_after.id} ({guild_id}) が一人以下になりました。寝落ち確認を開始します。メンバー: {lonely_member.id}")
+                task = asyncio.create_task(self.sleep_check_manager.check_lonely_channel(guild_id, channel_after.id, lonely_member.id))
+                self.sleep_check_manager.add_lonely_channel(guild_id, channel_after.id, lonely_member.id, task)
+        # 移動先チャンネルが複数人になった場合、一人以下の状態を解除
+        elif len(channel_after.members) > 1:
+            if key_after in self.sleep_check_manager.lonely_voice_channels:
+                logger.debug(f"移動先チャンネル {channel_after.id} ({guild_id}) に複数人が入室しました。一人以下の状態を解除します。")
                 self.sleep_check_manager.remove_lonely_channel(guild_id, channel_after.id)
 
-            # VoiceStateManager に処理を委譲し、統計更新が必要なデータを取得
-            ended_sessions_from_before, joined_session_data = await self.voice_state_manager.handle_member_move(member, channel_before, channel_after)
-
-            # 移動元での退出による統計更新とマイルストーン通知
-            for member_id_leave, duration_leave, join_time_leave in ended_sessions_from_before:
-                before_total_leave = await get_total_call_time(member_id_leave)
-                month_key_leave = join_time_leave.strftime("%Y-%m")
-                await update_member_monthly_stats(month_key_leave, member_id_leave, duration_leave)
-                after_total_leave = await get_total_call_time(member_id_leave)
-                m_obj_leave = member.guild.get_member(member_id_leave) if member.guild else None
-                if m_obj_leave:
-                    await utils.check_and_notify_milestone(self.bot, m_obj_leave, member.guild, before_total_leave, after_total_leave)
-
-            # 移動先での入室による統計更新とマイルストーン通知 (移動してきたメンバー自身の場合のみ)
-            if joined_session_data is not None:
-                 member_id_join, duration_join, join_time_join = joined_session_data
-                 before_total_join = await get_total_call_time(member_id_join)
-                 month_key_join = join_time_join.strftime("%Y-%m")
-                 await update_member_monthly_stats(month_key_join, member_id_join, 0) # 移動直後は通話時間0として記録
-                 after_total_join = await get_total_call_time(member_id_join)
-                 m_obj_join = member.guild.get_member(member_id_join) if member.guild else None
-                 if m_obj_join:
-                     await utils.check_and_notify_milestone(self.bot, m_obj_join, member.guild, before_total_join, after_total_join)
-
-
-            # ボットによってミュートされたメンバーがチャンネル移動した場合、ミュートを解除
-            if member.id in self.sleep_check_manager.bot_muted_members:
-                async def unmute_after_delay(m: discord.Member):
-                    await asyncio.sleep(1) # 1秒待機
-                    try:
-                        await m.edit(mute=False, deafen=False)
-                        self.sleep_check_manager.remove_bot_muted_member(m.id)
-                        print(f"メンバー {m.display_name} ({m.id}) がチャンネル移動したためミュートを解除しました。")
+        # VoiceStateManager に処理を委譲し、統計更新が必要なデータを取得
+        ended_sessions_from_before, joined_session_data = await self.voice_state_manager.handle_member_move(member, channel_before, channel_after)
+        logger.debug(f"VoiceStateManager.handle_member_move 処理完了。メンバー: {member.id}, 移動元: {channel_before.id}, 移動先: {channel_after.id}. 終了セッション数: {len(ended_sessions_from_before)}, 参加セッションデータ: {joined_session_data is not None}")
+
+        # 移動元での退出による統計更新とマイルストーン通知
+        for member_id_leave, duration_leave, join_time_leave in ended_sessions_from_before:
+            logger.debug(f"移動元退出による統計更新処理を開始します。メンバー: {member_id_leave}, 期間: {duration_leave}, 参加時刻: {join_time_leave}")
+            before_total_leave = await get_total_call_time(member_id_leave)
+            month_key_leave = join_time_leave.strftime("%Y-%m")
+            await update_member_monthly_stats(month_key_leave, member_id_leave, duration_leave)
+            after_total_leave = await get_total_call_time(member_id_leave)
+            logger.debug(f"メンバー {member_id_leave} の月間統計を更新しました。Before Total: {before_total_leave}, After Total: {after_total_leave}")
+            m_obj_leave = member.guild.get_member(member_id_leave) if member.guild else None
+            if m_obj_leave:
+                 await self._check_and_notify_milestone(m_obj_leave, member.guild, before_total_leave, after_total_leave)
+
+        # 移動先での入室による統計更新とマイルストーン通知 (移動してきたメンバー自身の場合のみ)
+        if joined_session_data is not None:
+             member_id_join, duration_join, join_time_join = joined_session_data
+             logger.debug(f"移動先入室による統計更新処理を開始します。メンバー: {member_id_join}, 期間: {duration_join}, 参加時刻: {join_time_join}")
+             before_total_join = await get_total_call_time(member_id_join)
+             month_key_join = join_time_join.strftime("%Y-%m")
+             # 移動直後は通話時間0として記録（新しいセッションの開始）
+             await update_member_monthly_stats(month_key_join, member_id_join, 0)
+             after_total_join = await get_total_call_time(member_id_join)
+             logger.debug(f"メンバー {member_id_join} の月間統計を更新しました。Before Total: {before_total_join}, After Total: {after_total_join}")
+             m_obj_join = member.guild.get_member(member_id_join) if member.guild else None
+             if m_obj_join:
+                 await self._check_and_notify_milestone(m_obj_join, member.guild, before_total_join, after_total_join)
+
+
+        # ボットによってミュートされたメンバーがチャンネル移動した場合、ミュートを解除
+        if member.id in self.sleep_check_manager.bot_muted_members:
+            logger.info(f"ボットによってミュートされたメンバー {member.id} がチャンネル移動しました。ミュート解除をスケジュールします。")
+            async def unmute_after_delay(m: discord.Member):
+                logger.debug(f"メンバー {m.id} のミュート解除遅延処理を開始します。")
+                await asyncio.sleep(constants.UNMUTE_DELAY_SECONDS) # 1秒待機
+                try:
+                    await m.edit(mute=False, deafen=False)
+                    self.sleep_check_manager.remove_bot_muted_member(m.id)
+                    logger.info(f"メンバー {m.display_name} ({m.id}) がチャンネル移動したためミュートを解除しました。")
+
+                    notification_channel_id = config.get_notification_channel_id(m.guild.id)
+                    if notification_channel_id:
+                        notification_channel = self.bot.get_channel(notification_channel_id)
+                        if notification_channel:
+                            try:
+                                embed = discord.Embed(title=constants.EMBED_TITLE_SLEEP_CHECK, description=f"{m.mention}{constants.EMBED_DESCRIPTION_UNMUTE_ON_REJOIN}", color=constants.EMBED_COLOR_SUCCESS)
+                                await notification_channel.send(embed=embed)
+                                logger.info(f"チャンネル移動時ミュート解除メッセージをチャンネル {notification_channel.id} に送信しました。")
+                            except discord.Forbidden:
+                                logger.error(f"エラー: チャンネル {notification_channel.name} ({notification_channel.id}) への送信権限がありません。")
+                            except Exception as e:
+                                logger.error(f"チャンネル移動時ミュート解除メッセージ送信中にエラーが発生しました: {e}")
+
+                except discord.Forbidden:
+                    logger.error(f"エラー: メンバー {m.display_name} ({m.id}) のミュートを解除する権限がありません。")
+                except Exception as e:
+                    logger.error(f"メンバーミュート解除中にエラーが発生しました: {e}")
+                logger.debug(f"メンバー {m.id} のミュート解除遅延処理が完了しました。")
+
+            asyncio.create_task(unmute_after_delay(member))
+
+    # 同一チャンネル内での状態変化（ミュート、デフなど）の処理
+    async def _handle_state_change(self, member, before, after):
+        logger.debug(f"メンバー {member.id} の同一チャンネル内での状態変化を検出しました。チャンネル: {before.channel.id}")
+        # このメソッドは、同一チャンネル内でのミュート、デフ、ストリーム開始/終了などの状態変化を処理するために存在します。
+        # 現在の要件ではこれらの状態変化に対して特別なアクションは必要ないため、passしています。
+        # 将来的にこれらの状態変化に対応する機能を追加する場合に、このメソッド内にロジックを記述します。
+        pass
 
-                        notification_channel_id = config.get_notification_channel_id(m.guild.id)
-                        if notification_channel_id:
-                            notification_channel = self.bot.get_channel(notification_channel_id)
-                            if notification_channel:
-                                try:
-                                    embed = discord.Embed(title="寝落ちミュート", description=f"{m.mention} さんがチャンネル移動したため、サーバーミュートを解除しました。", color=discord.Color.green())
-                                    await notification_channel.send(embed=embed)
-                                except discord.Forbidden:
-                                    print(f"エラー: チャンネル {notification_channel.name} ({notification_channel.id}) への送信権限がありません。")
-                                except Exception as e:
-                                    print(f"チャンネル移動時ミュート解除メッセージ送信中にエラーが発生しました: {e}")
+    @commands.Cog.listener()
+    async def on_voice_state_update(self, member, before, after):
+        logger.info(f"on_voice_state_update イベント発生: メンバー {member.id}, Before: {before.channel}, After: {after.channel}")
+        channel_before = before.channel
+        channel_after = after.channel
 
-                    except discord.Forbidden:
-                        print(f"エラー: メンバー {m.display_name} ({m.id}) のミュートを解除する権限がありません。")
-                    except Exception as e:
-                        print(f"メンバーミュート解除中にエラーが発生しました: {e}")
-
-                asyncio.create_task(unmute_after_delay(member))
-
-
-        # 同一チャンネル内での状態変化の場合は何もしない
-        elif channel_before == channel_after:
-            pass # 既存の処理を維持するため pass を使用
-
-        # 通話終了処理 (before.channel から完全に退出した場合)
-        elif before.channel is not None and after.channel is None:
-             # VoiceStateManager に処理を委譲し、統計更新が必要なデータを取得
-            ended_sessions_data = await self.voice_state_manager.handle_member_leave(member, before.channel)
-            # VoiceStateManager から統計更新が必要なデータが返された場合、各メンバーごとに処理
-            for member_id, duration, join_time in ended_sessions_data:
-                before_total = await get_total_call_time(member_id)
-                month_key = join_time.strftime("%Y-%m")
-                await update_member_monthly_stats(month_key, member_id, duration)
-                after_total = await get_total_call_time(member_id)
-                m_obj = member.guild.get_member(member_id) if member.guild else None
-                if m_obj:
-                    await utils.check_and_notify_milestone(self.bot, m_obj, member.guild, before_total, after_total)
-
-        # 通話開始処理 (before.channel が None で after.channel が None でない場合)
-        elif before.channel is None and after.channel is not None:
-             # VoiceStateManager に処理を委譲
-             await self.voice_state_manager.handle_member_join(member, after.channel)
-
-             # ボットによってミュートされたメンバーが再入室した場合、ミュートを解除
-             if member.id in self.sleep_check_manager.bot_muted_members:
-                 async def unmute_after_delay(m: discord.Member):
-                     await asyncio.sleep(1) # 1秒待機
-                     try:
-                         await m.edit(mute=False, deafen=False)
-                         self.sleep_check_manager.remove_bot_muted_member(m.id)
-                         print(f"メンバー {m.display_name} ({m.id}) が再入室したためミュートを解除しました。")
-
-                         notification_channel_id = config.get_notification_channel_id(m.guild.id)
-                         if notification_channel_id:
-                             notification_channel = self.bot.get_channel(notification_channel_id)
-                             if notification_channel:
-                                 try:
-                                     embed = discord.Embed(title="寝落ちミュート", description=f"{m.mention} さんが再入室したため、サーバーミュートを解除しました。", color=discord.Color.green())
-                                     await notification_channel.send(embed=embed)
-                                 except discord.Forbidden:
-                                     print(f"エラー: チャンネル {notification_channel.name} ({notification_channel.id}) への送信権限がありません。")
-                                 except Exception as e:
-                                     print(f"再入室時ミュート解除メッセージ送信中にエラーが発生しました: {e}")
-
-                     except discord.Forbidden:
-                         print(f"エラー: メンバー {m.display_name} ({m.id}) のミュートを解除する権限がありません。")
-                     except Exception as e:
-                         print(f"メンバーミュート解除中にエラーが発生しました: {e}")
-
-                 asyncio.create_task(unmute_after_delay(member))
+        if channel_before is None and channel_after is not None:
+            # チャンネルに入室した場合
+            await self._handle_join(member, channel_after)
+        elif channel_before is not None and channel_after is None:
+            # チャンネルから退出した場合
+            await self._handle_leave(member, channel_before)
+        elif channel_before is not None and channel_after is not None and channel_before != channel_after:
+            # チャンネル間を移動した場合
+            await self._handle_move(member, channel_before, channel_after)
+        elif channel_before is not None and channel_after is not None and channel_before == channel_after:
+            # 同一チャンネル内での状態変化
+            await self._handle_state_change(member, before, after)
 
         # --- 2人以上通話状態の記録（各メンバーごとに個別記録＋全参加者リストを維持する処理） ---
         # この部分は VoiceStateManager に移動したので削除
diff --git a/voice_state_manager.py b/voice_state_manager.py
index df31c19..07f075e 100644
--- a/voice_state_manager.py
+++ b/voice_state_manager.py
@@ -2,367 +2,635 @@ import discord
 from discord.ext import tasks
 import datetime
 from zoneinfo import ZoneInfo
+import logging # logging モジュールをインポート
 
 from database import record_voice_session_to_db
 from formatters import format_duration, convert_utc_to_jst
 from config import get_notification_channel_id
+import constants # constants モジュールをインポート
 
+# ロガーを取得
+logger = logging.getLogger(__name__)
 
 class VoiceStateManager:
+    """
+    ボイスチャンネルの状態管理、通話セッションの記録、通話通知、
+    および2人以上の通話状態の追跡とステータス更新を行います。
+    """
     def __init__(self, bot):
         self.bot = bot
+        logger.info("VoiceStateManager initialized.")
         # 通話開始時間と最初に通話を開始した人を記録する辞書（通話通知用）
         # キー: (guild_id, voice_channel_id), 値: {"start_time": datetimeオブジェクト, "first_member": member_id}
         self.call_sessions = {}
+        logger.debug("call_sessions 辞書を初期化しました。")
 
         # (guild_id, channel_id) をキーに、現在進行中の「2人以上通話セッション」を記録する
         # 値: {"session_start": datetimeオブジェクト, "current_members": {member_id: join_time}, "all_participants": {member_id}}
+        # session_start: そのチャンネルで2人以上の通話が開始された時刻
+        # current_members: 現在そのチャンネルにいるメンバーとそのチャンネルに参加した時刻
+        # all_participants: そのセッション中に一度でもチャンネルに参加した全てのメンバーIDのセット
         self.active_voice_sessions = {}
+        logger.debug("active_voice_sessions 辞書を初期化しました。")
 
         # 2人以上が通話中のチャンネルを追跡するセット
         # 要素: (guild_id, channel_id)
         self.active_status_channels = set()
+        logger.debug("active_status_channels セットを初期化しました。")
 
-        # ステータス通話時間更新タスク
-        self.update_call_status_task = tasks.loop(seconds=15)(self._update_call_status_task)
+        # ボットのステータスを通話時間で更新するタスク
+        self.update_call_status_task = tasks.loop(seconds=constants.STATUS_UPDATE_INTERVAL_SECONDS)(self._update_call_status_task)
+        logger.debug(f"ステータス更新タスクを {constants.STATUS_UPDATE_INTERVAL_SECONDS} 秒間隔で設定しました。")
 
     # --- ボイスステート更新ハンドラ ---
     async def handle_member_join(self, member: discord.Member, channel_after: discord.VoiceChannel):
-        """メンバーがチャンネルに参加した時の処理"""
+        """
+        メンバーがボイスチャンネルに参加した時に呼び出されるハンドラ。
+        通話通知機能と2人以上通話状態の記録を処理します。
+        """
+        logger.info(f"handle_member_join: メンバー {member.id} がチャンネル {channel_after.id} ({channel_after.name}) に参加しました。")
         guild_id = member.guild.id
         now = datetime.datetime.now(datetime.timezone.utc)
         key = (guild_id, channel_after.id)
+        logger.debug(f"ギルドID: {guild_id}, チャンネルID: {channel_after.id}")
 
         # 通話通知機能 (入室時)
+        # ギルド内でそのチャンネルでの通話が開始された最初のメンバーであれば通知を送信します。
         if guild_id not in self.call_sessions:
             self.call_sessions[guild_id] = {}
+            logger.debug(f"ギルド {guild_id} の call_sessions エントリを作成しました。")
         if channel_after.id not in self.call_sessions[guild_id]:
-            start_time = now
-            self.call_sessions[guild_id][channel_after.id] = {"start_time": start_time, "first_member": member.id}
-            jst_time = convert_utc_to_jst(start_time)
-            embed = discord.Embed(title="通話開始", color=discord.Color.red())
-            embed.set_thumbnail(url=f"{member.avatar.url}?size=128")
-            embed.add_field(name="チャンネル", value=f"{channel_after.name}")
-            embed.add_field(name="始めた人", value=f"{member.display_name}")
-            embed.add_field(name="開始時間", value=f"{jst_time.strftime('%Y/%m/%d %H:%M:%S')}")
-            notification_channel_id = get_notification_channel_id(guild_id)
-            if notification_channel_id:
-                notification_channel = self.bot.get_channel(notification_channel_id)
-                if notification_channel:
-                    await notification_channel.send(content="@everyone", embed=embed, allowed_mentions=discord.AllowedMentions(everyone=True))
-                else:
-                    print(f"通知チャンネルが見つかりません:ギルドID {guild_id}")
+             # 新しい通話セッションの開始時刻と最初のメンバーを記録
+             start_time = now
+             self.call_sessions[guild_id][channel_after.id] = {"start_time": start_time, "first_member": member.id}
+             logger.info(f"チャンネル {channel_after.id} ({guild_id}) で新しい通話セッションを開始しました。開始時刻: {start_time}, 最初のメンバー: {member.id}")
+             # JSTに変換して表示用にフォーマット
+             jst_time = convert_utc_to_jst(start_time)
+             # 通話開始通知用のEmbedを作成
+             embed = discord.Embed(title=constants.EMBED_TITLE_CALL_START, color=constants.EMBED_COLOR_CALL_START)
+             embed.set_thumbnail(url=f"{member.avatar.url}?size=128")
+             embed.add_field(name=constants.EMBED_FIELD_CHANNEL, value=f"{channel_after.name}")
+             embed.add_field(name=constants.EMBED_FIELD_STARTED_BY, value=f"{member.display_name}")
+             embed.add_field(name=constants.EMBED_FIELD_START_TIME, value=f"{jst_time.strftime('%Y/%m/%d %H:%M:%S')}")
+             # 通知チャンネルを取得し、通知を送信
+             notification_channel_id = get_notification_channel_id(guild_id)
+             if notification_channel_id:
+                 notification_channel = self.bot.get_channel(notification_channel_id)
+                 if notification_channel:
+                     try:
+                         await notification_channel.send(content=constants.MENTION_EVERYONE, embed=embed, allowed_mentions=constants.ALLOWED_MENTIONS_EVERYONE)
+                         logger.info(f"通話開始通知をチャンネル {notification_channel_id} に送信しました。")
+                     except discord.Forbidden:
+                         logger.error(f"エラー: チャンネル {notification_channel.name} ({notification_channel_id}) への送信権限がありません。")
+                     except Exception as e:
+                         logger.error(f"通話開始通知送信中にエラーが発生しました: {e}")
+                 else:
+                     # 通知チャンネルが見つからない場合のログ出力
+                     logger.warning(f"通知チャンネルが見つかりません:ギルドID {guild_id}")
+             else:
+                 logger.info(f"ギルド {guild_id} の通知チャンネルが設定されていません。通話開始通知は送信されません。")
+        else:
+            logger.debug(f"チャンネル {channel_after.id} ({guild_id}) に既存の通話セッションがあります。通話開始通知はスキップします。")
+
 
         # 2人以上通話状態の記録（各メンバーごとに個別記録＋全参加者リストを維持する処理）
-        # チャンネル内の人数が2人以上の場合
-        if len(channel_after.members) >= 2:
+        # チャンネル内の人数がconstants.MIN_MEMBERS_FOR_SESSION (現在2) 人以上の場合に、
+        # 新しいセッションを開始するか、既存のセッションにメンバーを追加します。
+        if len(channel_after.members) >= constants.MIN_MEMBERS_FOR_SESSION:
+            logger.debug(f"チャンネル {channel_after.id} ({guild_id}) の人数が {constants.MIN_MEMBERS_FOR_SESSION} 人以上 ({len(channel_after.members)} 人) です。")
             if key not in self.active_voice_sessions:
-                # セッション開始時刻は、通話が2人以上になった時刻（この時点の now）
+                logger.info(f"チャンネル {channel_after.id} ({guild_id}) で新しい2人以上通話セッションを開始します。")
+                # 新しい2人以上通話セッションを開始
+                # セッション開始時刻は、通話がconstants.MIN_MEMBERS_FOR_SESSION人以上になった時刻（この時点の now）
                 self.active_voice_sessions[key] = {
                     "session_start": now,
-                    "current_members": { m.id: now for m in channel_after.members },
-                    "all_participants": set(m.id for m in channel_after.members)
+                    "current_members": { m.id: now for m in channel_after.members }, # 現在のメンバーとその参加時刻を記録
+                    "all_participants": set(m.id for m in channel_after.members) # 全参加者リストに現在のメンバーを追加
                 }
+                logger.debug(f"新しい active_voice_sessions エントリを作成しました: {key}")
             else:
-                # 既存のセッションがある場合、新たに入室したメンバーを更新する
+                logger.debug(f"チャンネル {channel_after.id} ({guild_id}) に既存の2人以上通話セッションがあります。メンバーリストを更新します。")
+                # 既存の2人以上通話セッションがある場合、新たに入室したメンバーを更新する
                 session_data = self.active_voice_sessions[key]
                 for m in channel_after.members:
                     if m.id not in session_data["current_members"]:
-                        session_data["current_members"][m.id] = now
-                    session_data["all_participants"].add(m.id)
+                        session_data["current_members"][m.id] = now # 新規参加メンバーの参加時刻を記録
+                        logger.debug(f"メンバー {m.id} を active_voice_sessions[{key}]['current_members'] に追加しました。")
+                    session_data["all_participants"].add(m.id) # 全参加者リストにメンバーを追加
+                    logger.debug(f"メンバー {m.id} を active_voice_sessions[{key}]['all_participants'] に追加しました。")
 
-            # チャンネルの人数が2人以上になったら active_status_channels に追加
+
+            # チャンネルの人数がconstants.MIN_MEMBERS_FOR_SESSION人以上になったら active_status_channels に追加
             if key not in self.active_status_channels:
                 self.active_status_channels.add(key)
-                # 初めて2人以上の通話が始まった場合、ステータス更新タスクを開始
+                logger.debug(f"チャンネル {key} を active_status_channels に追加しました。")
+                # 初めて2人以上の通話が始まった場合、ボットのステータス更新タスクを開始
                 if not self.update_call_status_task.is_running():
                     self.update_call_status_task.start()
+                    logger.info("ボットのステータス更新タスクを開始しました。")
 
         else:
-            # 人数が2人未満の場合は、既にセッションが存在する場合のみ更新する
+            logger.debug(f"チャンネル {channel_after.id} ({guild_id}) の人数が {constants.MIN_MEMBERS_FOR_SESSION} 人未満 ({len(channel_after.members)} 人) です。")
+            # 人数がconstants.MIN_MEMBERS_FOR_SESSION人未満の場合は、既にセッションが存在する場合のみ更新する
+            # （一時的に人数が減ってもセッション自体は継続しているとみなす）
             if key in self.active_voice_sessions:
+                logger.debug(f"チャンネル {channel_after.id} ({guild_id}) に既存の2人以上通話セッションがあります。メンバーリストを更新します。")
                 session_data = self.active_voice_sessions[key]
                 for m in channel_after.members:
                     if m.id not in session_data["current_members"]:
-                        session_data["current_members"][m.id] = now
-                    session_data["all_participants"].add(m.id)
+                        session_data["current_members"][m.id] = now # 新規参加メンバーの参加時刻を記録
+                        logger.debug(f"メンバー {m.id} を active_voice_sessions[{key}]['current_members'] に追加しました。")
+                    session_data["all_participants"].add(m.id) # 全参加者リストにメンバーを追加
+                    logger.debug(f"メンバー {m.id} を active_voice_sessions[{key}]['all_participants'] に追加しました。")
+            else:
+                logger.debug(f"チャンネル {channel_after.id} ({guild_id}) にアクティブな2人以上通話セッションはありません。")
+
 
     async def handle_member_leave(self, member: discord.Member, channel_before: discord.VoiceChannel):
-        """メンバーがチャンネルから退出した時の処理"""
+        """
+        メンバーがボイスチャンネルから退出した時に呼び出されるハンドラ。
+        通話通知機能と2人以上通話状態の記録を処理します。
+        """
+        logger.info(f"handle_member_leave: メンバー {member.id} がチャンネル {channel_before.id} ({channel_before.name}) から退出しました。")
         guild_id = member.guild.id
         now = datetime.datetime.now(datetime.timezone.utc)
         key = (guild_id, channel_before.id)
+        logger.debug(f"ギルドID: {guild_id}, チャンネルID: {channel_before.id}")
 
         # 通話通知機能 (退出時)
         voice_channel_before_id = channel_before.id
+        # 退出元のチャンネルでの通話セッションが存在する場合
         if guild_id in self.call_sessions and voice_channel_before_id in self.call_sessions[guild_id]:
             voice_channel = channel_before
-            # 退出元のチャンネルに誰もいなくなった場合のみ通話終了とみなす
+            # 退出元のチャンネルに誰もいなくなった場合のみ通話終了とみなし、通知を送信
             if len(voice_channel.members) == 0:
-                session = self.call_sessions[guild_id].pop(voice_channel_before_id)
+                logger.info(f"チャンネル {voice_channel_before_id} ({guild_id}) に誰もいなくなりました。通話終了とみなします。")
+                session = self.call_sessions[guild_id].pop(voice_channel_before_id) # 通話セッションを終了
                 start_time = session["start_time"]
-                call_duration = (now - start_time).total_seconds()
-                duration_str = format_duration(call_duration)
-                embed = discord.Embed(title="通話終了", color=discord.Color.blurple())
+                call_duration = (now - start_time).total_seconds() # 通話時間を計算
+                duration_str = format_duration(call_duration) # 表示用にフォーマット
+                logger.debug(f"通話時間: {duration_str}")
+                # 通話終了通知用のEmbedを作成
+                embed = discord.Embed(title=constants.EMBED_TITLE_CALL_END, color=constants.EMBED_COLOR_CALL_END)
                 embed.add_field(name="チャンネル", value=f"{voice_channel.name}")
                 embed.add_field(name="通話時間", value=f"{duration_str}")
+                # 通知チャンネルを取得し、通知を送信
                 notification_channel_id = get_notification_channel_id(guild_id)
                 if notification_channel_id:
                     notification_channel = self.bot.get_channel(notification_channel_id)
                     if notification_channel:
-                        await notification_channel.send(embed=embed)
+                        try:
+                            await notification_channel.send(embed=embed)
+                            logger.info(f"通話終了通知をチャンネル {notification_channel_id} に送信しました。")
+                        except discord.Forbidden:
+                            logger.error(f"エラー: チャンネル {notification_channel.name} ({notification_channel_id}) への送信権限がありません。")
+                        except Exception as e:
+                            logger.error(f"通話終了通知送信中にエラーが発生しました: {e}")
                     else:
-                        print(f"通知チャンネルが見つかりません:ギルドID {guild_id}")
+                        # 通知チャンネルが見つからない場合のログ出力
+                        logging.warning(f"通知チャンネルが見つかりません:ギルドID {guild_id}")
+                else:
+                    logger.info(f"ギルド {guild_id} の通知チャンネルが設定されていません。通話終了通知は送信されません。")
+            else:
+                logger.debug(f"チャンネル {voice_channel_before_id} ({guild_id}) にまだメンバーがいます ({len(voice_channel.members)} 人)。通話終了とはみなしません。")
+        else:
+            logger.debug(f"チャンネル {voice_channel_before_id} ({guild_id}) にアクティブな通話セッションはありません。")
+
 
         # 2人以上通話状態の記録（各メンバーごとに個別記録＋全参加者リストを維持する処理）
+        # 退出元のチャンネルで2人以上通話セッションがアクティブな場合
+        ended_sessions_data = [] # 終了した個別のメンバーセッションデータを収集するリスト
         if key in self.active_voice_sessions:
+            logger.debug(f"チャンネル {channel_before.id} ({guild_id}) にアクティブな2人以上通話セッションがあります。")
             session_data = self.active_voice_sessions[key]
-            ended_sessions_data = [] # Collect data for ended individual sessions
 
-            # もし対象メンバーが在室中ならその個人分の退室処理を実施
+            # もし対象メンバーが現在セッションに在室中ならその個人分の退室処理を実施
             if member.id in session_data["current_members"]:
-                join_time = session_data["current_members"].pop(member.id)
-                duration = (now - join_time).total_seconds()
-                ended_sessions_data.append((member.id, duration, join_time)) # Add to list
+                logger.debug(f"メンバー {member.id} が active_voice_sessions[{key}]['current_members'] に存在します。個人セッションを終了します。")
+                join_time = session_data["current_members"].pop(member.id) # メンバーを現在のメンバーリストから削除
+                duration = (now - join_time).total_seconds() # そのメンバーの通話時間を計算
+                ended_sessions_data.append((member.id, duration, join_time)) # 終了リストに追加
+                logger.debug(f"メンバー {member.id} の個人セッション終了データ: 期間 {duration}, 参加時刻 {join_time}")
+            else:
+                logger.debug(f"メンバー {member.id} は active_voice_sessions[{key}]['current_members'] に存在しませんでした。")
+
 
-            # もし退室後、チャンネル内人数が1人以下ならセッション終了処理を実施
-            if channel_before is not None and len(channel_before.members) < 2:
-                # セッション終了時の残メンバーの統計更新と通知チェック
+            # もし退室後、チャンネル内人数がconstants.MIN_MEMBERS_FOR_SESSION (現在2) 人未満になったら
+            # そのチャンネルでの2人以上通話セッション全体を終了する処理を実施
+            if channel_before is not None and len(channel_before.members) < constants.MIN_MEMBERS_FOR_SESSION:
+                logger.info(f"チャンネル {channel_before.id} ({guild_id}) の人数が {constants.MIN_MEMBERS_FOR_SESSION} 人未満 ({len(channel_before.members)} 人) になりました。2人以上通話セッションを終了します。")
+                # セッション終了時の残メンバーの統計更新と通知チェック（voice_events.pyで処理）
                 remaining_members_data = session_data["current_members"].copy()
                 for m_id, join_time in remaining_members_data.items():
                     d = (now - join_time).total_seconds()
-                    ended_sessions_data.append((m_id, d, join_time)) # Add to list
-                    session_data["current_members"].pop(m_id) # Remove from current members
+                    ended_sessions_data.append((m_id, d, join_time)) # 終了リストに追加
+                    logger.debug(f"終了セッションに残っていたメンバー {m_id} のデータ: 期間 {d}, 参加時刻 {join_time}")
+                    session_data["current_members"].pop(m_id) # 残メンバーを現在のメンバーリストから削除
 
+                # セッション全体の通話時間を計算し、データベースに記録
                 overall_duration = (now - session_data["session_start"]).total_seconds()
+                logger.info(f"チャンネル {channel_before.id} ({guild_id}) の2人以上通話セッション全体を記録します。開始時刻: {session_data['session_start']}, 期間: {overall_duration}, 全参加者: {list(session_data['all_participants'])}")
                 await record_voice_session_to_db(session_data["session_start"], overall_duration, list(session_data["all_participants"]))
-                self.active_voice_sessions.pop(key, None)
-
-                # チャンネルの人数が1人以下になったら active_status_channels から削除
-                if channel_before is not None and len(channel_before.members) < 2:
-                    self.active_status_channels.discard(key)
-                    # 2人以上の通話がすべて終了した場合、ステータス更新タスクを停止しステータスをクリア
-                    if not self.active_status_channels and self.update_call_status_task.is_running():
-                        self.update_call_status_task.stop()
-                        await self.bot.change_presence(activity=None)
-
-            return ended_sessions_data # Return the list of ended sessions data
+                self.active_voice_sessions.pop(key, None) # アクティブセッションから削除
+                logger.debug(f"チャンネル {key} を active_voice_sessions から削除しました。")
+
+                # チャンネルの人数がconstants.MIN_MEMBERS_FOR_SESSION人未満になったら active_status_channels から削除
+                self.active_status_channels.discard(key)
+                logger.debug(f"チャンネル {key} を active_status_channels から削除しました。")
+                # 2人以上の通話がすべて終了した場合、ボットのステータス更新タスクを停止しステータスをクリア
+                if not self.active_status_channels and self.update_call_status_task.is_running():
+                    self.update_call_status_task.stop()
+                    await self.bot.change_presence(activity=None)
+                    logger.info("アクティブな2人以上通話チャンネルがなくなったため、ステータス更新タスクを停止しステータスをクリアしました。")
+            else:
+                logger.debug(f"チャンネル {channel_before.id} ({guild_id}) にまだ {constants.MIN_MEMBERS_FOR_SESSION} 人以上 ({len(channel_before.members)} 人) います。2人以上通話セッションは継続します。")
 
-        return [] # Return empty list if no active session or no sessions ended
+        return ended_sessions_data # 終了した個別のメンバーセッションデータのリストを返す
 
     async def handle_member_move(self, member: discord.Member, channel_before: discord.VoiceChannel, channel_after: discord.VoiceChannel):
-        """メンバーがチャンネル間を移動した時の処理"""
+        """
+        メンバーがボイスチャンネル間を移動した時に呼び出されるハンドラ。
+        移動元チャンネルからの退出処理と移動先チャンネルへの入室処理を組み合わせます。
+        """
+        logger.info(f"handle_member_move: メンバー {member.id} がチャンネル {channel_before.id} ({channel_before.name}) からチャンネル {channel_after.id} ({channel_after.name}) に移動しました。")
         guild_id = member.guild.id
         now = datetime.datetime.now(datetime.timezone.utc)
         key_before = (guild_id, channel_before.id)
         key_after = (guild_id, channel_after.id)
+        logger.debug(f"ギルドID: {guild_id}, 移動元チャンネルID: {channel_before.id}, 移動先チャンネルID: {channel_after.id}")
 
-        # 移動元チャンネルからの退出処理 (通話通知用)
+        # 通話通知機能 (移動元からの退出処理)
         voice_channel_before_id = channel_before.id
+        # 移動元のチャンネルでの通話セッションが存在する場合
         if guild_id in self.call_sessions and voice_channel_before_id in self.call_sessions[guild_id]:
             voice_channel = channel_before
-            # 移動元のチャンネルに誰もいなくなった場合のみ通話終了とみなす
+            # 移動元のチャンネルに誰もいなくなった場合のみ通話終了とみなし、通知を送信
             if len(voice_channel.members) == 0:
-                session = self.call_sessions[guild_id].pop(voice_channel_before_id)
+                logger.info(f"移動元チャンネル {voice_channel_before_id} ({guild_id}) に誰もいなくなりました。通話終了とみなします。")
+                session = self.call_sessions[guild_id].pop(voice_channel_before_id) # 通話セッションを終了
                 start_time = session["start_time"]
-                call_duration = (now - start_time).total_seconds()
-                duration_str = format_duration(call_duration)
-                embed = discord.Embed(title="通話終了", color=discord.Color.blurple())
+                call_duration = (now - start_time).total_seconds() # 通話時間を計算
+                duration_str = format_duration(call_duration) # 表示用にフォーマット
+                logger.debug(f"通話時間: {duration_str}")
+                # 通話終了通知用のEmbedを作成
+                embed = discord.Embed(title=constants.EMBED_TITLE_CALL_END, color=constants.EMBED_COLOR_CALL_END)
                 embed.add_field(name="チャンネル", value=f"{voice_channel.name}")
                 embed.add_field(name="通話時間", value=f"{duration_str}")
+                # 通知チャンネルを取得し、通知を送信
                 notification_channel_id = get_notification_channel_id(guild_id)
                 if notification_channel_id:
                     notification_channel = self.bot.get_channel(notification_channel_id)
                     if notification_channel:
-                        await notification_channel.send(embed=embed)
+                        try:
+                            await notification_channel.send(embed=embed)
+                            logger.info(f"通話終了通知をチャンネル {notification_channel_id} に送信しました。")
+                        except discord.Forbidden:
+                            logger.error(f"エラー: チャンネル {notification_channel.name} ({notification_channel_id}) への送信権限がありません。")
+                        except Exception as e:
+                            logger.error(f"通話終了通知送信中にエラーが発生しました: {e}")
                     else:
-                        print(f"通知チャンネルが見つかりません:ギルドID {guild_id}")
+                        # 通知チャンネルが見つからない場合のログ出力
+                        logging.warning(f"通知チャンネルが見つかりません:ギルドID {guild_id}")
+                else:
+                    logger.info(f"ギルド {guild_id} の通知チャンネルが設定されていません。通話終了通知は送信されません。")
+            else:
+                logger.debug(f"移動元チャンネル {voice_channel_before_id} ({guild_id}) にまだメンバーがいます ({len(voice_channel.members)} 人)。通話終了とはみなしません。")
+        else:
+            logger.debug(f"移動元チャンネル {voice_channel_before_id} ({guild_id}) にアクティブな通話セッションはありません。")
+
 
         # 移動先チャンネルへの入室処理 (通話通知用)
         voice_channel_after_id = channel_after.id
         if guild_id not in self.call_sessions:
             self.call_sessions[guild_id] = {}
+            logger.debug(f"ギルド {guild_id} の call_sessions エントリを作成しました。")
         # 移動先のチャンネルに誰もいない状態から一人になった場合、または最初から一人で通話に参加した場合に通話開始とみなす
         if voice_channel_after_id not in self.call_sessions[guild_id] and len(channel_after.members) == 1:
+             logger.info(f"移動先チャンネル {voice_channel_after_id} ({guild_id}) で新しい通話セッションを開始します。")
+             # 新しい通話セッションの開始時刻と最初のメンバーを記録
              start_time = now
              self.call_sessions[guild_id][voice_channel_after_id] = {"start_time": start_time, "first_member": member.id}
+             # JSTに変換して表示用にフォーマット
              jst_time = convert_utc_to_jst(start_time)
-             embed = discord.Embed(title="通話開始", color=discord.Color.red())
+             # 通話開始通知用のEmbedを作成
+             embed = discord.Embed(title=constants.EMBED_TITLE_CALL_START, color=constants.EMBED_COLOR_CALL_START)
              embed.set_thumbnail(url=f"{member.avatar.url}?size=128")
-             embed.add_field(name="チャンネル", value=f"{channel_after.name}")
-             embed.add_field(name="始めた人", value=f"{member.display_name}")
-             embed.add_field(name="開始時間", value=f"{jst_time.strftime('%Y/%m/%d %H:%M:%S')}")
+             embed.add_field(name=constants.EMBED_FIELD_CHANNEL, value=f"{channel_after.name}")
+             embed.add_field(name=constants.EMBED_FIELD_STARTED_BY, value=f"{member.display_name}")
+             embed.add_field(name=constants.EMBED_FIELD_START_TIME, value=f"{jst_time.strftime('%Y/%m/%d %H:%M:%S')}")
+             # 通知チャンネルを取得し、通知を送信
              notification_channel_id = get_notification_channel_id(guild_id)
              if notification_channel_id:
                  notification_channel = self.bot.get_channel(notification_channel_id)
                  if notification_channel:
-                     await notification_channel.send(content="@everyone", embed=embed, allowed_mentions=discord.AllowedMentions(everyone=True))
+                     try:
+                         await notification_channel.send(content=constants.MENTION_EVERYONE, embed=embed, allowed_mentions=constants.ALLOWED_MENTIONS_EVERYONE)
+                         logger.info(f"通話開始通知をチャンネル {notification_channel_id} に送信しました。")
+                     except discord.Forbidden:
+                         logger.error(f"エラー: チャンネル {notification_channel.name} ({notification_channel_id}) への送信権限がありません。")
+                     except Exception as e:
+                         logger.error(f"通話開始通知送信中にエラーが発生しました: {e}")
                  else:
-                     print(f"通知チャンネルが見つかりません:ギルドID {guild_id}")
+                     # 通知チャンネルが見つからない場合のログ出力
+                     logging.warning(f"通知チャンネルが見つかりません:ギルドID {guild_id}")
+             else:
+                 logger.info(f"ギルド {guild_id} の通知チャンネルが設定されていません。通話開始通知は送信されません。")
+        else:
+            logger.debug(f"チャンネル {voice_channel_after_id} ({guild_id}) に既存の通話セッションがあるか、人数が1人ではありません。通話開始通知はスキップします。")
+
 
         # 2人以上通話状態の記録（各メンバーごとに個別記録＋全参加者リストを維持する処理）
+        # 移動元チャンネルからの退出処理と移動先チャンネルへの入室処理を統合して扱います。
 
-        ended_sessions_from_before = [] # Collect data for sessions ending in channel_before
-        joined_session_data = None # Data for the member joining channel_after
+        ended_sessions_from_before = [] # 移動元チャンネルで終了した個別のメンバーセッションデータを収集するリスト
+        joined_session_data = None # 移動先チャンネルに参加したメンバーのデータ
 
         # 移動元チャンネルからの退出処理
+        # 移動元チャンネルで2人以上通話セッションがアクティブな場合
         if key_before in self.active_voice_sessions:
+            logger.debug(f"移動元チャンネル {channel_before.id} ({guild_id}) にアクティブな2人以上通話セッションがあります。")
             session_data_before = self.active_voice_sessions[key_before]
+            # 移動したメンバーが現在セッションに在室中ならその個人分の退室処理を実施
             if member.id in session_data_before["current_members"]:
-                join_time_leave = session_data_before["current_members"].pop(member.id)
-                duration_leave = (now - join_time_leave).total_seconds()
-                ended_sessions_from_before.append((member.id, duration_leave, join_time_leave)) # Add to list
+                logger.debug(f"メンバー {member.id} が active_voice_sessions[{key_before}]['current_members'] に存在します。個人セッションを終了します。")
+                join_time_leave = session_data_before["current_members"].pop(member.id) # メンバーを現在のメンバーリストから削除
+                duration_leave = (now - join_time_leave).total_seconds() # そのメンバーの通話時間を計算
+                ended_sessions_from_before.append((member.id, duration_leave, join_time_leave)) # 終了リストに追加
+                logger.debug(f"メンバー {member.id} の個人セッション終了データ: 期間 {duration_leave}, 参加時刻 {join_time_leave}")
+            else:
+                logger.debug(f"メンバー {member.id} は active_voice_sessions[{key_before}]['current_members'] に存在しませんでした。")
+
 
-            if len(channel_before.members) < 2:
-                # セッション終了時の残メンバーの統計更新と通知チェック
+            # 移動元チャンネルの人数がconstants.MIN_MEMBERS_FOR_SESSION (現在2) 人未満になったら
+            # そのチャンネルでの2人以上通話セッション全体を終了する処理を実施
+            if len(channel_before.members) < constants.MIN_MEMBERS_FOR_SESSION:
+                logger.info(f"移動元チャンネル {channel_before.id} ({guild_id}) の人数が {constants.MIN_MEMBERS_FOR_SESSION} 人未満 ({len(channel_before.members)} 人) になりました。2人以上通話セッションを終了します。")
+                # セッション終了時の残メンバーの統計更新と通知チェック（voice_events.pyで処理）
                 remaining_members_data = session_data_before["current_members"].copy()
                 for m_id, join_time in remaining_members_data.items():
                     d = (now - join_time).total_seconds()
-                    ended_sessions_from_before.append((m_id, d, join_time)) # Add to list
-                    session_data_before["current_members"].pop(m_id) # Remove from current members
+                    ended_sessions_from_before.append((m_id, d, join_time)) # 終了リストに追加
+                    logger.debug(f"終了セッションに残っていたメンバー {m_id} のデータ: 期間 {d}, 参加時刻 {join_time}")
+                    session_data_before["current_members"].pop(m_id) # 残メンバーを現在のメンバーリストから削除
 
+                # セッション全体の通話時間を計算し、データベースに記録
                 overall_duration = (now - session_data_before["session_start"]).total_seconds()
+                logger.info(f"チャンネル {channel_before.id} ({guild_id}) の2人以上通話セッション全体を記録します。開始時刻: {session_data_before['session_start']}, 期間: {overall_duration}, 全参加者: {list(session_data_before['all_participants'])}")
                 await record_voice_session_to_db(session_data_before["session_start"], overall_duration, list(session_data_before["all_participants"]))
-                self.active_voice_sessions.pop(key_before, None)
+                self.active_voice_sessions.pop(key_before, None) # アクティブセッションから削除
+                logger.debug(f"チャンネル {key_before} を active_voice_sessions から削除しました。")
+
+                # チャンネルの人数がconstants.MIN_MEMBERS_FOR_SESSION人未満になったら active_status_channels から削除
+                self.active_status_channels.discard(key_before)
+                logger.debug(f"チャンネル {key_before} を active_status_channels から削除しました。")
+                # 2人以上の通話がすべて終了した場合、ボットのステータス更新タスクを停止しステータスをクリア
+                if not self.active_status_channels and self.update_call_status_task.is_running():
+                    self.update_call_status_task.stop()
+                    await self.bot.change_presence(activity=None)
+                    logger.info("アクティブな2人以上通話チャンネルがなくなったため、ステータス更新タスクを停止しステータスをクリアしました。")
+            else:
+                logger.debug(f"移動元チャンネル {channel_before.id} ({guild_id}) にまだ {constants.MIN_MEMBERS_FOR_SESSION} 人以上 ({len(channel_before.members)} 人) います。2人以上通話セッションは継続します。")
+
+        else:
+            logger.debug(f"移動元チャンネル {channel_before.id} ({guild_id}) にアクティブな2人以上通話セッションはありませんでした。")
 
-                if len(channel_before.members) < 2:
-                    self.active_status_channels.discard(key_before)
-                    if not self.active_status_channels and self.update_call_status_task.is_running():
-                        self.update_call_status_task.stop()
-                        await self.bot.change_presence(activity=None)
 
         # 移動先チャンネルへの入室処理
-        if len(channel_after.members) >= 2:
+        # 移動先チャンネルの人数がconstants.MIN_MEMBERS_FOR_SESSION (現在2) 人以上の場合
+        if len(channel_after.members) >= constants.MIN_MEMBERS_FOR_SESSION:
+            logger.debug(f"移動先チャンネル {channel_after.id} ({guild_id}) の人数が {constants.MIN_MEMBERS_FOR_SESSION} 人以上 ({len(channel_after.members)} 人) です。")
             if key_after not in self.active_voice_sessions:
+                logger.info(f"移動先チャンネル {channel_after.id} ({guild_id}) で新しい2人以上通話セッションを開始します。")
+                # 新しい2人以上通話セッションを開始
                 self.active_voice_sessions[key_after] = {
                     "session_start": now,
-                    "current_members": { m.id: now for m in channel_after.members },
-                    "all_participants": set(m.id for m in channel_after.members)
+                    "current_members": { m.id: now for m in channel_after.members }, # 現在のメンバーとその参加時刻を記録
+                    "all_participants": set(m.id for m in channel_after.members) # 全参加者リストに現在のメンバーを追加
                 }
+                logger.debug(f"新しい active_voice_sessions エントリを作成しました: {key_after}")
             else:
+                logger.debug(f"移動先チャンネル {channel_after.id} ({guild_id}) に既存の2人以上通話セッションがあります。メンバーリストを更新します。")
+                # 既存の2人以上通話セッションがある場合、新たに入室したメンバーを更新する
                 session_data_after = self.active_voice_sessions[key_after]
                 for m in channel_after.members:
                     if m.id not in session_data_after["current_members"]:
-                        session_data_after["current_members"][m.id] = now
+                        session_data_after["current_members"][m.id] = now # 新規参加メンバーの参加時刻を記録
+                        logger.debug(f"メンバー {m.id} を active_voice_sessions[{key_after}]['current_members'] に追加しました。")
                         if m.id == member.id: # 移動してきたメンバーの場合
-                            # For the joining member, we only need their ID and join time for potential future calculation
-                            # Duration is 0 at the moment of joining
+                            # 移動してきたメンバーのデータとしてID、現在の通話時間（この時点では0）、参加時刻を記録
                             joined_session_data = (m.id, 0, now)
-                    session_data_after["all_participants"].add(m.id)
+                            logger.debug(f"移動してきたメンバー {m.id} の joined_session_data を記録しました。")
+                    session_data_after["all_participants"].add(m.id) # 全参加者リストにメンバーを追加
+                    logger.debug(f"メンバー {m.id} を active_voice_sessions[{key_after}]['all_participants'] に追加しました。")
+
 
+            # チャンネルの人数がconstants.MIN_MEMBERS_FOR_SESSION人以上になったら active_status_channels に追加
             if key_after not in self.active_status_channels:
                 self.active_status_channels.add(key_after)
+                logger.debug(f"チャンネル {key_after} を active_status_channels に追加しました。")
+                # 初めて2人以上の通話が始まった場合、ボットのステータス更新タスクを開始
                 if not self.update_call_status_task.is_running():
                     self.update_call_status_task.start()
+                    logger.info("ボットのステータス更新タスクを開始しました。")
         else:
+            logger.debug(f"移動先チャンネル {channel_after.id} ({guild_id}) の人数が {constants.MIN_MEMBERS_FOR_SESSION} 人未満 ({len(channel_after.members)} 人) です。")
+            # 移動先チャンネルの人数がconstants.MIN_MEMBERS_FOR_SESSION人未満の場合は、既にセッションが存在する場合のみ更新する
+            # （一時的に人数が減ってもセッション自体は継続しているとみなす）
             if key_after in self.active_voice_sessions:
+                logger.debug(f"移動先チャンネル {channel_after.id} ({guild_id}) に既存の2人以上通話セッションがあります。メンバーリストを更新します。")
                 session_data_after = self.active_voice_sessions[key_after]
                 for m in channel_after.members:
                     if m.id not in session_data_after["current_members"]:
-                        session_data_after["current_members"][m.id] = now
+                        session_data_after["current_members"][m.id] = now # 新規参加メンバーの参加時刻を記録
+                        logger.debug(f"メンバー {m.id} を active_voice_sessions[{key_after}]['current_members'] に追加しました。")
                         if m.id == member.id: # 移動してきたメンバーの場合
+                            # 移動してきたメンバーのデータとしてID、現在の通話時間（この時点では0）、参加時刻を記録
                             joined_session_data = (m.id, 0, now)
-                    session_data_after["all_participants"].add(m.id)
+                            logger.debug(f"移動してきたメンバー {m.id} の joined_session_data を記録しました。")
+                    session_data_after["all_participants"].add(m.id) # 全参加者リストにメンバーを追加
+                    logger.debug(f"メンバー {m.id} を active_voice_sessions[{key_after}]['all_participants'] に追加しました。")
+            else:
+                logger.debug(f"移動先チャンネル {channel_after.id} ({guild_id}) にアクティブな2人以上通話セッションはありません。")
 
 
-        # Return data for sessions that ended in channel_before and data for the member joining channel_after
+        # 移動元チャンネルで終了した個別のメンバーセッションデータのリストと、
+        # 移動先チャンネルに参加したメンバーのデータを返す
         return ended_sessions_from_before, joined_session_data
 
 
     # --- 二人以上の通話時間計算ヘルパー関数 ---
     def calculate_call_duration_seconds(self, start_time):
-        """開始時刻からの経過秒数を計算する"""
+        """
+        指定された開始時刻からの経過秒数を計算します。
+        ボットのステータス更新タスクで使用されます。
+        """
         now = datetime.datetime.now(datetime.timezone.utc)
-        return (now - start_time).total_seconds()
+        duration = (now - start_time).total_seconds()
+        logger.debug(f"開始時刻 {start_time} からの経過時間: {duration} 秒")
+        return duration
 
     # アクティブな通話チャンネルとその通話時間を取得する
     def get_active_call_durations(self, guild_id: int):
-        """指定されたギルドのアクティブな通話チャンネルとその通話時間を取得する"""
+        """
+        指定されたギルドのアクティブな2人以上通話チャンネルとその通話時間を取得し、
+        表示用にフォーマットして返します。/call_duration コマンドで使用されます。
+        """
+        logger.info(f"ギルド {guild_id} のアクティブな通話チャンネルの通話時間を取得します。")
         active_calls = []
         now = datetime.datetime.now(datetime.timezone.utc)
+        # アクティブな2人以上通話セッションを全て確認
         for key, session_data in self.active_voice_sessions.items():
+            # 指定されたギルドのセッションのみを対象とする
             if key[0] == guild_id:
                 channel = self.bot.get_channel(key[1])
+                # チャンネルが存在し、ボイスチャンネルであることを確認
                 if channel and isinstance(channel, discord.VoiceChannel):
+                    # セッション開始からの経過時間を計算
                     duration_seconds = (now - session_data["session_start"]).total_seconds()
+                    # 表示用にフォーマット
                     formatted_duration = format_duration(duration_seconds)
+                    # チャンネル名とフォーマット済み通話時間をリストに追加
                     active_calls.append({"channel_name": channel.name, "duration": formatted_duration})
+                    logger.debug(f"アクティブな通話チャンネル: {channel.name}, 通話時間: {formatted_duration}")
+                else:
+                    logger.warning(f"アクティブセッションのチャンネル {key[1]} ({key[0]}) が見つからないかボイスチャンネルではありません。")
+        logger.info(f"ギルド {guild_id} のアクティブな通話チャンネル数: {len(active_calls)}")
+        # アクティブな通話チャンネルとその通話時間のリストを返す
         return active_calls
 
     # --- ステータス通話時間更新タスク ---
     async def _update_call_status_task(self):
-        """ボットのステータスを通話時間で更新するタスク"""
+        """
+        ボットのステータスを現在アクティブな2人以上通話チャンネルの通話時間で更新するタスク。
+        constants.STATUS_UPDATE_INTERVAL_SECONDS 間隔で実行されます。
+        """
+        logger.debug("ステータス更新タスクを実行します。")
+        # 2人以上通話中のチャンネルがあるか確認
         if self.active_status_channels:
-            # active_status_channelsからステータスに表示するチャンネルを選択
+            logger.debug(f"アクティブなステータスチャンネルがあります: {self.active_status_channels}")
+            # active_status_channelsからステータスに表示するチャンネルを一つ選択（セットなので順序は保証されない）
             channel_key_to_display = next(iter(self.active_status_channels))
             guild_id, channel_id = channel_key_to_display
             guild = self.bot.get_guild(guild_id)
             channel = self.bot.get_channel(channel_id)
 
+            # ギルド、チャンネルが存在し、かつそのチャンネルがまだアクティブセッションリストにあるか確認
             if guild and channel and channel_key_to_display in self.active_voice_sessions:
-                # 選択したチャンネルの通話時間を計算し、ステータスに設定
+                logger.debug(f"ステータスに表示するチャンネル: {channel.name} ({guild.name})")
+                # 選択したチャンネルの通話時間を計算
                 session_data = self.active_voice_sessions[channel_key_to_display]
                 duration_seconds = self.calculate_call_duration_seconds(session_data["session_start"])
+                # 表示用にフォーマット
                 formatted_duration = format_duration(duration_seconds)
+                # ボットのカスタムステータスを設定
                 activity = discord.CustomActivity(name=f"{channel.name}: {formatted_duration}")
                 await self.bot.change_presence(activity=activity)
+                logger.info(f"ボットのステータスを更新しました: {activity.name}")
             else:
-                # チャンネルが見つからない、またはactive_voice_sessionsにない場合はセットから削除しステータスをクリア
+                logger.warning(f"ステータス表示対象チャンネル {channel_key_to_display} が見つからないか、アクティブセッションにありません。")
+                # チャンネルが見つからない、またはactive_voice_sessionsにない場合は
+                # active_status_channels から削除し、2人以上通話がすべて終了していればステータスをクリア
                 self.active_status_channels.discard(channel_key_to_display)
+                logger.debug(f"チャンネル {channel_key_to_display} を active_status_channels から削除しました。")
                 if not self.active_status_channels:
                      await self.bot.change_presence(activity=None)
+                     logger.info("アクティブなステータスチャンネルがなくなったため、ステータスをクリアしました。")
         else:
-            # 2人以上の通話がない場合はステータスをクリア
+            logger.debug("アクティブなステータスチャンネルがありません。ステータスをクリアします。")
+            # 2人以上の通話がない場合はボットのステータスをクリア
             await self.bot.change_presence(activity=None)
+            logger.info("ボットのステータスをクリアしました。")
 
     async def record_session_end(self, guild_id: int, channel_id: int):
-        """通話セッション終了時の処理（データベース記録など）"""
+        """
+        特定のチャンネルでの2人以上通話セッションが終了した時の処理。
+        セッション全体の通話時間をデータベースに記録し、アクティブセッションリストから削除します。
+        終了した個別のメンバーセッションデータを返します（統計更新と通知チェックは voice_events.py で行います）。
+        """
+        logger.info(f"チャンネル {channel_id} ({guild_id}) の2人以上通話セッション終了処理を開始します。")
         key = (guild_id, channel_id)
+        ended_sessions_data = [] # 終了した個別のメンバーセッションデータを収集するリスト
+
+        # 指定されたチャンネルの2人以上通話セッションがアクティブな場合
         if key in self.active_voice_sessions:
             session_data = self.active_voice_sessions[key]
             now = datetime.datetime.now(datetime.timezone.utc)
+            logger.debug(f"チャンネル {key} にアクティブなセッションが見つかりました。")
 
-            # セッション終了時の残メンバーの統計更新と通知チェック
+            # セッション終了時の残メンバーの統計更新と通知チェックのためにデータを収集
             remaining_members_data = session_data["current_members"].copy()
             for m_id, join_time in remaining_members_data.items():
                 d = (now - join_time).total_seconds()
+                ended_sessions_data.append((m_id, d, join_time)) # 終了リストに追加
+                logger.debug(f"終了セッションに残っていたメンバー {m_id} のデータ: 期間 {d}, 参加時刻 {join_time}")
+                session_data["current_members"].pop(m_id) # 残メンバーを現在のメンバーリストから削除
+                logger.debug(f"メンバー {m_id} を active_voice_sessions[{key}]['current_members'] から削除しました。")
 
-                # 統計更新とマイルストーン通知は voice_events.py で行うため、ここではデータを返さない
-                pass
-
-                session_data["current_members"].pop(m_id)
 
+            # セッション全体の通話時間を計算し、データベースに記録
             overall_duration = (now - session_data["session_start"]).total_seconds()
+            logger.info(f"チャンネル {channel_id} ({guild_id}) の2人以上通話セッション全体を記録します。開始時刻: {session_data['session_start']}, 期間: {overall_duration}, 全参加者: {list(session_data['all_participants'])}")
             await record_voice_session_to_db(session_data["session_start"], overall_duration, list(session_data["all_participants"]))
-            self.active_voice_sessions.pop(key, None)
+            self.active_voice_sessions.pop(key, None) # アクティブセッションから削除
+            logger.debug(f"チャンネル {key} を active_voice_sessions から削除しました。")
 
             # チャンネルの人数が1人以下になったら active_status_channels から削除
             self.active_status_channels.discard(key)
-            # 2人以上の通話がすべて終了した場合、ステータス更新タスクを停止しステータスをクリア
+            logger.debug(f"チャンネル {key} を active_status_channels から削除しました。")
+            # 2人以上の通話がすべて終了した場合、ボットのステータス更新タスクを停止しステータスをクリア
             if not self.active_status_channels and self.update_call_status_task.is_running():
                 self.update_call_status_task.stop()
                 await self.bot.change_presence(activity=None)
+                logger.info("アクティブな2人以上通話チャンネルがなくなったため、ステータス更新タスクを停止しステータスをクリアしました。")
+        else:
+            logger.warning(f"チャンネル {channel_id} ({guild_id}) にアクティブな2人以上通話セッションはありませんでした。終了処理はスキップします。")
+
+        return ended_sessions_data # 終了した個別のメンバーセッションデータのリストを返す
+
 
     def start_session(self, guild_id: int, channel_id: int, members: list[discord.Member]):
-        """新しい通話セッションを開始する"""
+        """
+        新しい2人以上通話セッションを開始します。
+        voice_events.py でチャンネルにconstants.MIN_MEMBERS_FOR_SESSION人以上になった時に呼び出されます。
+        """
+        logger.info(f"チャンネル {channel_id} ({guild_id}) で新しい2人以上通話セッションを開始します。")
         key = (guild_id, channel_id)
         now = datetime.datetime.now(datetime.timezone.utc)
+        # 新しいセッションデータを初期化
         self.active_voice_sessions[key] = {
-            "session_start": now,
-            "current_members": { m.id: now for m in members },
-            "all_participants": set(m.id for m in members)
+            "session_start": now, # セッション開始時刻
+            "current_members": { m.id: now for m in members }, # 現在のメンバーとその参加時刻
+            "all_participants": set(m.id for m in members) # 全参加者リスト
         }
+        logger.debug(f"新しい active_voice_sessions エントリを作成しました: {key}")
+        # active_status_channels にチャンネルを追加
         self.active_status_channels.add(key)
+        logger.debug(f"チャンネル {key} を active_status_channels に追加しました。")
+        # ステータス更新タスクが実行中でなければ開始
         if not self.update_call_status_task.is_running():
             self.update_call_status_task.start()
+            logger.info("ボットのステータス更新タスクを開始しました。")
 
     def update_session_members(self, guild_id: int, channel_id: int, members: list[discord.Member]):
-        """既存の通話セッションのメンバーリストを更新する"""
+        """
+        既存の2人以上通話セッションのメンバーリストを更新します。
+        チャンネルにメンバーが追加された際に呼び出され、新規参加メンバーをセッションに追加します。
+        """
+        logger.info(f"チャンネル {channel_id} ({guild_id}) の2人以上通話セッションのメンバーリストを更新します。")
         key = (guild_id, channel_id)
         now = datetime.datetime.now(datetime.timezone.utc)
+        # 指定されたチャンネルの2人以上通話セッションがアクティブな場合
         if key in self.active_voice_sessions:
+            logger.debug(f"チャンネル {key} にアクティブなセッションが見つかりました。")
             session_data = self.active_voice_sessions[key]
+            # チャンネルにいる各メンバーを確認
             for m in members:
+                # まだセッションのcurrent_membersリストにいないメンバーであれば追加
                 if m.id not in session_data["current_members"]:
-                    session_data["current_members"][m.id] = now
-                session_data["all_participants"].add(m.id)
+                    session_data["current_members"][m.id] = now # 参加時刻を記録
+                    logger.debug(f"メンバー {m.id} を active_voice_sessions[{key}]['current_members'] に追加しました。")
+                session_data["all_participants"].add(m.id) # 全参加者リストに追加
+                logger.debug(f"メンバー {m.id} を active_voice_sessions[{key}]['all_participants'] に追加しました。")
+            logger.debug(f"チャンネル {key} のメンバーリスト更新が完了しました。現在のメンバー: {list(session_data['current_members'].keys())}, 全参加者: {list(session_data['all_participants'])}")
+        else:
+            logger.warning(f"チャンネル {channel_id} ({guild_id}) にアクティブな2人以上通話セッションはありませんでした。メンバーリストの更新はスキップします。")
